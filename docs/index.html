<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta property="og:title" content="XferLang Data-Interchange Language" />
    <meta property="og:description" content="XferLang is a data-interchange format designed to support data serialization, data transmission, and offline use cases such as configuration management." />
    <meta property="og:image" content="https://xferlang.org/XferLang-sm.png" />
    <meta property="og:url" content="https://xferlang.org/" />
    <meta property="og:type" content="website" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XferLang Documentation</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="highlightjs/styles/github.min.css">
    <script src="script.js"></script>
    <script src="highlightjs/highlight.min.js"></script>
    <script src="highlightjs/languages/xfer.min.js"></script>
</head>
<body>
    <div class="mobile-nav-toggle">
        ☰
    </div>
    <nav class="sidebar">
        <div class="sidebar-header">
            <h2><a href="index.html" class="home-link">XferLang</a></h2>
            <div class="main-nav-links">
                <a href="index.html" class="nav-link">Guide</a>
                <a href="api.html" class="nav-link">API</a>
            </div>
        </div>
        <ul>
            <li><a href="#introduction">Introduction</a></li>
            <li>
                <details>
                    <summary>Getting Started</summary>
                    <ul>
                <li><a href="#why-xferlang">Why XferLang</a></li>
                <li><a href="#quick-xferlang-example">Quick XferLang Example</a></li>
                <li><a href="#visual-studio-code-extension">Visual Studio Code Extension</a></li>
                    </ul>
                </details>
            </li>
            <li><a href="#project-status-and-roadmap">Project Status and Roadmap</a></li>
            <li>
                <details>
                    <summary>XferLang Basics</summary>
                    <ul>
                <li><a href="#elements-and-collections">Elements and Collections</a></li>
                <li><a href="#specifiers-and-the-andquotno-escapesandquot-rule">Specifiers and the &quot;No Escapes&quot; Rule</a></li>
                <li><a href="#processing-instructions">Processing Instructions</a></li>
                <li><a href="#interpolated-text">Interpolated Text</a></li>
                    </ul>
                </details>
            </li>
            <li>
                <details>
                    <summary>Introduction to the .NET Library</summary>
                    <ul>
                <li><a href="#parse-and-serialize">Parse and Serialize</a></li>
                <li><a href="#object-mapping-xferconvert">Object Mapping (XferConvert)</a></li>
                <li><a href="#configuration-xferserializersettings">Configuration (XferSerializerSettings)</a></li>
                <li><a href="#binding-references-with-let">Binding References with let</a></li>
                <li><a href="#grouped-let-bindings-with-script">Grouped Let Bindings with script</a></li>
                <li><a href="#dynamic-elements-and-sources">Dynamic Elements and Sources</a></li>
                <li><a href="#conditional-element-inclusion-with-if">Conditional Element Inclusion with if</a></li>
                <li><a href="#character-definitions">Character Definitions</a></li>
                    </ul>
                </details>
            </li>
            <li>
                <details>
                    <summary>Core Concepts</summary>
                    <ul>
                <li><a href="#elements-and-syntax-forms">Elements and Syntax Forms</a></li>
                <li><a href="#collections">Collections</a></li>
                <li><a href="#keywords-vs-identifiers">Keywords vs Identifiers</a></li>
                <li><a href="#numbers">Numbers</a></li>
                <li><a href="#text-and-characters">Text and Characters</a></li>
                <li><a href="#date-and-time">Date and Time</a></li>
                <li><a href="#null">Null</a></li>
                <li><a href="#binding-and-reference">Binding and Reference</a></li>
                <li><a href="#interpolated-text">Interpolated Text</a></li>
                <li><a href="#dynamic-elements">Dynamic Elements</a></li>
                <li><a href="#processing-instructions-pis">Processing Instructions (PIs)</a></li>
                    </ul>
                </details>
            </li>
            <li>
                <details>
                    <summary>XferLang Language Specification</summary>
                    <ul>
                <li><a href="#document-structure">Document Structure</a></li>
                <li><a href="#element-syntax-variations">Element Syntax Variations</a></li>
                    </ul>
                </details>
            </li>
            <li>
                <details>
                    <summary>XferLang Element Reference</summary>
                    <ul>
                <li><a href="#primitive-types">Primitive Types</a></li>
                <li><a href="#hexadecimal-and-binary-formatting">Hexadecimal and Binary Formatting</a></li>
                <li><a href="#collection-elements">Collection Elements</a></li>
                <li><a href="#special-purpose-types">Special-Purpose Types</a></li>
                <li><a href="#common-document-patterns">Common Document Patterns</a></li>
                    </ul>
                </details>
            </li>
            <li>
                <details>
                    <summary>Complete Examples</summary>
                    <ul>
                <li><a href="#configuration-file-example">Configuration File Example</a></li>
                <li><a href="#user-profile-example">User Profile Example</a></li>
                    </ul>
                </details>
            </li>
            <li>
                <details>
                    <summary>The .NET XferLang Library</summary>
                    <ul>
                <li><a href="#getting-started-with-net">Getting Started with .NET</a></li>
                <li><a href="#basic-serialization-and-deserialization">Basic Serialization and Deserialization</a></li>
                <li><a href="#working-with-collections">Working with Collections</a></li>
                <li><a href="#advanced-usage-with-xferserializersettings">Advanced Usage with XferSerializerSettings</a></li>
                    </ul>
                </details>
            </li>
            <li>
                <details>
                    <summary>Serializer Settings</summary>
                    <ul>
                <li><a href="#element-style-preferences">Element Style Preferences</a></li>
                <li><a href="#configuration-example">Configuration Example</a></li>
                <li><a href="#available-settings">Available Settings</a></li>
                    </ul>
                </details>
            </li>
            <li>
                <details>
                    <summary>Property Attributes</summary>
                    <ul>
                <li><a href="#xferpropertyattribute">XferPropertyAttribute</a></li>
                <li><a href="#xfernumericformatattribute">XferNumericFormatAttribute</a></li>
                <li><a href="#xferdecimalprecisionattribute">XferDecimalPrecisionAttribute</a></li>
                <li><a href="#safety-notes">Safety Notes</a></li>
                <li><a href="#processing-instructions-and-dynamic-content">Processing Instructions and Dynamic Content</a></li>
                <li><a href="#built-in-processing-instructions">Built-in Processing Instructions</a></li>
                <li><a href="#dynamic-elements-and-source-resolution">Dynamic Elements and Source Resolution</a></li>
                <li><a href="#extending-processing-instructions">Extending Processing Instructions</a></li>
                <li><a href="#writing-custom-processing-instructions">Writing Custom Processing Instructions</a></li>
                <li><a href="#when-to-create-a-pi">When to Create a PI</a></li>
                <li><a href="#parser-registration-model">Parser Registration Model</a></li>
                <li><a href="#minimal-custom-pi-example-trace">Minimal Custom PI Example (trace)</a></li>
                <li><a href="#conditioning-the-next-element">Conditioning the Next Element</a></li>
                <li><a href="#validation-pi-skeleton">Validation PI Skeleton</a></li>
                <li><a href="#extending-dynamic-resolution-no-new-pi-required">Extending Dynamic Resolution (No New PI Required)</a></li>
                <li><a href="#checklist-for-a-new-pi">Checklist for a New PI</a></li>
                <li><a href="#lifecycle-summary">Lifecycle Summary</a></li>
                    </ul>
                </details>
            </li>
            <li>
                <details>
                    <summary>Building XferLang</summary>
                    <ul>
                <li><a href="#prerequisites">Prerequisites</a></li>
                <li><a href="#quick-start">Quick Start</a></li>
                <li><a href="#project-structure">Project Structure</a></li>
                <li><a href="#development-commands">Development Commands</a></li>
                    </ul>
                </details>
            </li>
            <li>
                <details>
                    <summary>Community and Resources</summary>
                    <ul>
                <li><a href="#learning-resources">Learning Resources</a></li>
                <li><a href="#getting-help">Getting Help</a></li>
                    </ul>
                </details>
            </li>
            <li><a href="#contributing">Contributing</a></li>
            <li><a href="#grammar">Grammar</a></li>
        </ul>

    </nav>
    <main class="content">

<p><img src="https://raw.githubusercontent.com/paulmooreparks/Xfer/master/logo/XferLang-sm.png" alt="XferLogo" /></p>
<h1 id="xferlang">XferLang</h1>
<p><a href="https://github.com/paulmooreparks/Xfer"><img src="https://img.shields.io/github/last-commit/paulmooreparks/Xfer" alt="GitHub last commit" /></a>
<a href="https://github.com/paulmooreparks/Xfer/actions/workflows/dotnet.yml"><img src="https://github.com/paulmooreparks/Xfer/actions/workflows/dotnet.yml/badge.svg" alt=".NET Build Status" /></a>
<a href="https://www.nuget.org/packages/ParksComputing.Xfer.Lang"><img src="https://img.shields.io/nuget/vpre/ParksComputing.Xfer.Lang.svg" alt="NuGet" /></a>
<a href="https://github.com/paulmooreparks/Xfer/issues"><img src="https://img.shields.io/github/issues/paulmooreparks/Xfer" alt="GitHub issues" /></a>
<a href="https://opensource.org/licenses/MIT"><img src="https://img.shields.io/badge/License-MIT-yellow.svg" alt="License: MIT" /></a></p>
<hr />
<section id="introduction"><h2 id="introduction">Introduction</h2>
<p>XferLang is a typed, delimiter‑driven data format for data transfer, configuration, and structured content. If you know JSON, you'll feel at home using XferLang, but then you'll begin to notice what's different: explicit types, interpolated strings, no escape sequences, bound data references, and extensible processing instructions.</p>
<hr />
<section id="getting-started"><h2 id="getting-started">Getting Started</h2>
<section id="why-xferlang"><h3 id="why-xferlang">Why XferLang</h3>
<ul>
<li><strong>XferLang is readable without ceremony.</strong> Whitespace separates elements, and you may expand or collapse formatting without changing meaning.</li>
<li><strong>Types are explicit.</strong> There are no heuristics or guesswork.</li>
<li><strong>There is no escape tax.</strong> When content would collide with a delimiter, you may lengthen the delimiter instead of inserting backslashes.</li>
<li><strong>Parsing is programmable.</strong> Processing instructions declare metadata, bind names to elements for dynamic insertion, control parsing output, and compose elements from external sources. You may even develop your own custom processing instructions or extend the built-in ones.</li>
</ul>
<section id="quick-xferlang-example"><h3 id="quick-xferlang-example">Quick XferLang Example</h3>
<pre><code class="language-xfer">&lt;! document { version &quot;1&quot; } !&gt;
{
    title &quot;Demo&quot;
    active ~true
    retries 3
    ratio *0.8125
    launched @2025-08-01T09:30:00Z@
    tags [ &quot;alpha&quot; &quot;preview&quot; ]
    location ( *42.3601 *-71.0589 )
    banner 'User=&lt;|USER|&gt; ok=&lt;~true~&gt;'
}
</code></pre>
<section id="visual-studio-code-extension"><h3 id="visual-studio-code-extension">Visual Studio Code Extension</h3>
<p>Install the XferLang extension from the Visual Studio Marketplace to enable syntax highlighting and basic diagnostics.</p>
<p>Marketplace: <a href="https://marketplace.visualstudio.com/items?itemName=paulmooreparks.xferlang">https://marketplace.visualstudio.com/items?itemName=paulmooreparks.xferlang</a></p>
<p>Open a file with a .xfer file extension to activate the XferLang extension.</p>
<hr />
<section id="project-status-and-roadmap"><h2 id="project-status-and-roadmap">Project Status and Roadmap</h2>
<p>The .NET implementation of XferLang is becoming more robust, with a focus on professional-grade features like custom converters and contract resolvers. However, the project as a whole is still experimental.</p>
<p>The future roadmap includes:</p>
<ul>
<li>Completing the .NET implementation to achieve a production-quality 1.0 release</li>
<li>Reimplementing the core library in Rust</li>
<li>Exposing a C ABI from the Rust implementation</li>
<li>Creating language wrappers (e.g., for C#, Python, JavaScript) that communicate with the C ABI</li>
</ul>
<p>The goal of moving to a Rust core is to provide a single, high-performance, and memory-safe core for all future XferLang implementations. I'm looking for <a href="#contributing">contributors and collaborators</a> to get that work started.</p>
<hr />
<section id="xferlang-basics"><h2 id="xferlang-basics">XferLang Basics</h2>
<section id="elements-and-collections"><h3 id="elements-and-collections">Elements and Collections</h3>
<pre><code class="language-xfer">{
    name &quot;Alice&quot;
    age 30
    isMember ~true
    scores [ *85 *90 *78.5 ]
    profile {
        email &quot;alice@example.com&quot;
        joinedDate @2023-01-15T12:00:00@
    }
    point (*42.3601 *-71.0589)
    optional ?
}
</code></pre>
<p>Objects (<code>{}</code>) hold key/value pairs. Arrays (<code>[]</code>) are ordered and homogeneous (each item must be the same element type). Tuples (<code>()</code>) are ordered and heterogeneous (may contain multiple element types).</p>
<section id="specifiers-and-the-andquotno-escapesandquot-rule"><h3 id="specifiers-and-the-no-escapes-rule">Specifiers and the &quot;No Escapes&quot; Rule</h3>
<p>Instead of using escape sequences, you may lengthen the opening and closing specifier runs in order to enclose problematic content. The parser treats the contiguous run as the delimiter.</p>
<ul>
<li>Strings use <code>&quot;…&quot;</code>, and a longer run allows embedded quotes: <code>&quot;&quot;He said, \&quot;Hello\&quot;.&quot;&quot;</code>.</li>
<li>Interpolated text uses <code>'…'</code>, and a longer run allows embedded apostrophes: <code>''Outer 'inner' still fine''</code>.</li>
<li>Comments use <code>&lt;/ … /&gt;</code>, and a longer run allows nested markers: <code>&lt;// contains &lt;/ safely //&gt;</code>.</li>
<li>Use an explicit form by wrapping with <code>&lt;…&gt;</code> when you need to isolate internals.</li>
</ul>
<pre><code class="language-xfer">{
    nestedQuotes &quot;&quot;He said, &quot;Hello&quot; then left.&quot;&quot;
    dynamicWithPipe ||status|ok||
    &lt;// Outer comments containing &lt;/ inner comments /&gt; are fine //&gt;
    explicitDate &lt;@2025-08-01T12:00:00@&gt;
}
</code></pre>
<p>Pick the shortest run that avoids ambiguity.</p>
<section id="processing-instructions"><h3 id="processing-instructions">Processing Instructions</h3>
<p>Processing instructions (PIs) are single key/value directives that the parser consumes before continuing to parse. They use the form <code>&lt;! name &lt;value&gt; !&gt;</code>. The built‑in PIs include:</p>
<ul>
<li><code>document</code> – document metadata</li>
<li><code>dynamicSource</code> – map names to source handlers (file/env/const)</li>
<li><code>let</code> – bind a name to a value</li>
<li><code>script</code> – batch multiple operators and apply them before the next element</li>
<li><code>if</code> – conditionally suppress the next element</li>
<li><code>chardef</code> – define character aliases</li>
<li><code>id</code> - assign a unique identifier to the following element</li>
<li><code>tag</code> – assign a categorization tag to the following element</li>
</ul>
<pre><code class="language-xfer">&lt;! document { version &quot;1.2&quot; env &quot;prod&quot; } !&gt;
&lt;! dynamicSource { apiKey file &quot;secrets/api-key.txt&quot; user env &quot;USER&quot; tag const &quot;2025.08.11&quot; } !&gt;
&lt;! if defined |apiKey| !&gt; { auth { key |apiKey| user |user| tag |tag| } }
</code></pre>
<section id="interpolated-text"><h3 id="interpolated-text">Interpolated Text</h3>
<p>Interpolated‑text elements evaluate embedded elements to render a final text element. Like string elements, these will deserialize to a string type.</p>
<pre><code class="language-xfer">&lt;! dynamicSource { username env &quot;USER&quot; } !&gt;
&lt;/ Value will render as 'User=paul LoggedIn=True Since 1 Aug 2025 09:30:00' /&gt;
banner 'User=&lt;|username|&gt; LoggedIn=&lt;~true~&gt; Since &lt;@2025-08-01T09:30:00@&gt;'
</code></pre>
<hr />
<section id="introduction-to-the-net-library"><h2 id="introduction-to-the.net-library">Introduction to the .NET Library</h2>
<p>Install the NuGet package <a href="https://www.nuget.org/packages/ParksComputing.Xfer.Lang">ParksComputing.Xfer.Lang</a> to parse and serialize XferLang in .NET projects.</p>
<section id="parse-and-serialize"><h3 id="parse-and-serialize">Parse and Serialize</h3>
<pre><code class="language-csharp">using ParksComputing.Xfer.Lang.Services;

var parser = new Parser();
var doc = parser.Parse(&quot;{ name \&quot;Alice\&quot; age 30 }&quot;);

// Work with the document
var roundTrip = doc.ToXfer(); // Serialize back to XferLang
</code></pre>
<p>Warnings include row/column anchors to help locate issues:</p>
<pre><code class="language-csharp">foreach (var w in doc.Warnings) {
        Console.WriteLine($&quot;{w.Type} @ {w.Row}:{w.Column} — {w.Message} [{w.Context}]&quot;);
}
</code></pre>
<section id="object-mapping-xferconvert"><h3 id="object-mapping-xferconvert">Object Mapping (XferConvert)</h3>
<p><code>XferConvert</code> turns CLR objects into Xfer elements and back. This is useful for configuration scenarios and typed round‑trips.</p>
<pre><code class="language-csharp">using ParksComputing.Xfer.Lang;
using ParksComputing.Xfer.Lang.Configuration;

var settings = new XferSerializerSettings();

var person = new Person { Name = &quot;Ada&quot;, Age = 36 };
var element = XferConvert.FromObject(person, settings);  // ObjectElement
var xfer = element.ToXfer();

var back = XferConvert.ToObject&lt;Person&gt;((ObjectElement)element, settings);
</code></pre>
<p>Attributes influence names and number formatting:</p>
<pre><code class="language-csharp">using ParksComputing.Xfer.Lang.Attributes;

public class Person {
    [XferProperty(&quot;fullName&quot;)] public string Name { get; set; } = string.Empty;
    [XferNumericFormat(XferNumericFormat.Hex)] public int Favorite { get; set; }
}
</code></pre>
<section id="configuration-xferserializersettings"><h3 id="configuration-xferserializersettings">Configuration (XferSerializerSettings)</h3>
<p><code>XferSerializerSettings</code> controls naming, numeric formatting, decimal precision, and extension points. Highlights:</p>
<ul>
<li>ContractResolver (default: <code>DefaultContractResolver</code>)</li>
<li>Converters (<code>IXferConverter</code>) — optional custom type converters</li>
<li>Decimal and double precision (<code>XferDecimalPrecisionAttribute</code>)</li>
<li>Integer/long formatting (<code>XferNumericFormatAttribute</code>)</li>
</ul>
<pre><code class="language-csharp">using ParksComputing.Xfer.Lang.Configuration;
using ParksComputing.Xfer.Lang.ContractResolvers;
using ParksComputing.Xfer.Lang.Converters;

var settings = new XferSerializerSettings {
    ContractResolver = new DefaultContractResolver()
};

// Optional: add custom converters when you need specialized handling
settings.Converters.Add(new MySpecialConverter());
</code></pre>
<p>Note: Advanced serializer extension points (custom converters and custom contract resolvers) are supported and evolving. Keep tests nearby when extending.</p>
<hr />
<section id="binding-references-with-let"><h3 id="binding-references-with-let">Binding References with <code>let</code></h3>
<p>You may bind names to element values with the <code>let</code> processing instruction, and you may reference them in your document as reference elements.</p>
<pre><code class="language-xfer">&lt;! let greeting &quot;world&quot; !&gt;
message 'Hello &lt;_greeting_&gt;' &lt;/ &lt;_greeting_&gt; is replaced with &quot;world&quot; at parse time /&gt;
tuple ( _greeting _greeting ) &lt;/ Renders as tuple (&quot;world&quot; &quot;world&quot;) /&gt;
</code></pre>
<p>If a reference cannot be resolved at parse time, the reference element is rendered as-is and the parser reports a warning.</p>
<section id="grouped-let-bindings-with-script"><h3 id="grouped-let-bindings-with-script">Grouped Let Bindings with <code>script</code></h3>
<p>The <code>script</code> PI groups multiple <code>let</code> operators together.</p>
<pre><code class="language-xfer">&lt;! script (
    let x &quot;Hello&quot;
    let y 'X=&lt;_x_&gt;'
) !&gt;
(
    _x    &lt;/ Renders as &quot;Hello&quot; /&gt;
    _y    &lt;/ Renders as &quot;X=Hello&quot; /&gt;
)
</code></pre>
<p>In the future, additional keywords will be available for scripting as well.</p>
<section id="dynamic-elements-and-sources"><h3 id="dynamic-elements-and-sources">Dynamic Elements and Sources</h3>
<p>Dynamic elements (<code>|name|</code>) resolve from sources configured by <code>dynamicSource</code> or, absent a mapping, from environment variables. The built‑in source types are <code>env</code> to read environment variables, <code>file</code> to read files, and <code>const</code> for constant values.</p>
<pre><code class="language-xfer">&lt;! dynamicSource {
    apiKey file &quot;secrets/api-key.txt&quot;
    user   env  &quot;USER&quot;
    build  const &quot;2025.08.11&quot;
} !&gt;
{ key '|apiKey|' user '|user|' tag '|build|' }
</code></pre>
<section id="conditional-element-inclusion-with-if"><h3 id="conditional-element-inclusion-with-if">Conditional Element Inclusion with <code>if</code></h3>
<p>The <code>if</code> PI evaluates a condition. If the condition is false, the following sibling element is not added to the document. The <code>if</code> processing instruction itself is always stripped from output regardless of evaluation outcome.</p>
<pre><code class="language-xfer">&lt;! let showDebug ~false !&gt;
&lt;! if _showDebug !&gt;
{ debug { level &quot;verbose&quot; } }
</code></pre>
<p>Defined vs undefined (existence test) may also be used:</p>
<pre><code class="language-xfer">&lt;! if defined _showDebug !&gt; { note 'Evaluates as true even if the value is ~false.' }
</code></pre>
<p>Behavior &amp; serialization rules:</p>
<ul>
<li>If the condition evaluates to false, the target element (the immediately following sibling element) is completely suppressed; that is, it is never added to the parsed document model.</li>
<li>If the condition evaluates to true, the target element is retained.</li>
<li>Regardless of outcome (true, false, evaluation error, or unknown operator name) the <code>if</code> processing instruction itself is always stripped from serialization output. It acts only as a directive at parse time.</li>
<li>An unknown operator name inside the condition currently acts as a no‑op (treated as truthy so the element is preserved) but the PI is still stripped. Future versions may surface a warning; do not rely on serialization visibility for diagnostics.</li>
<li>Direct reference conditions (<code>&lt;! if _flag !&gt;</code>) test the bound value's truthiness; use <code>defined</code> to distinguish between an undefined binding and a defined but falsy value.</li>
</ul>
<p>Example showing outcomes (serialized form shown on right):</p>
<pre><code class="language-xfer">&lt;! let enabled ~true !&gt;  &lt;! if _enabled !&gt; { feature { status &quot;on&quot; } }   &lt;/ serializes as: { feature { status &quot;on&quot; } } /&gt;
&lt;! let enabled ~false !&gt; &lt;! if _enabled !&gt; { feature { status &quot;on&quot; } }   &lt;/ serializes as: (nothing emitted) /&gt;
&lt;! if someUnknownOp[&quot;a&quot; &quot;b&quot;] !&gt; { kept ~true }                         &lt;/ unknown op -&gt; element kept; PI stripped /&gt;
</code></pre>
<section id="character-definitions"><h3 id="character-definitions">Character Definitions</h3>
<p>Define symbolic character aliases for readability (keyword → Unicode code point):</p>
<pre><code class="language-xfer">&lt;! chardef { bullet \$2022 arrow \$2192 } !&gt;
{ list (&quot;Item&quot; \bullet &quot;Next&quot; \arrow ) }
</code></pre>
<hr />
<section id="core-concepts"><h2 id="core-concepts">Core Concepts</h2>
<section id="elements-and-syntax-forms"><h3 id="elements-and-syntax-forms">Elements and Syntax Forms</h3>
<p>Every value is an element. Most elements support three styles:</p>
<ul>
<li>Implicit: minimal form (e.g., <code>42</code>) when unambiguous.</li>
<li>Compact: type delimiter(s) (e.g., <code>#42</code>, <code>&quot;text&quot;</code>).</li>
<li>Explicit: wrapped in angle brackets (e.g., <code>&lt;#42#&gt;</code>, <code>&lt;&quot;A quote: &quot;&quot;&gt;</code>) allowing delimiter repetition.</li>
</ul>
<section id="collections"><h3 id="collections">Collections</h3>
<ul>
<li>Object: <code>{ key value ... }</code> (unordered key/value pairs; keys are keywords)</li>
<li>Array: <code>[ value value ... ]</code> (homogeneous)</li>
<li>Tuple: <code>( value value ... )</code> (heterogeneous)</li>
</ul>
<section id="keywords-vs-identifiers"><h3 id="keywords-vs-identifiers">Keywords vs Identifiers</h3>
<ul>
<li>Keywords (object keys) are implicit barewords composed only of letters, digits, and underscore: <code>[A-Za-z_][A-Za-z0-9_]*</code>.</li>
<li>If a key needs any other character (dash, space, etc.) wrap it with leading &amp; trailing <code>=</code> specifier runs: <code>=first-name=</code> (lengthen the run if it appears within the key itself).</li>
<li>Identifiers (<code>:name:</code>) are value elements (never keys). They always use leading and trailing <code>:</code>; they cannot contain whitespace or punctuation other than underscore.</li>
</ul>
<section id="numbers"><h3 id="numbers">Numbers</h3>
<p>Integers (<code>#</code> or implicit), longs (<code>&amp;</code>), decimals (<code>*</code> high precision), doubles (<code>^</code>). Alternate bases for integers/longs: hex <code>$</code>, binary <code>%</code>.</p>
<section id="text-and-characters"><h3 id="text-and-characters">Text and Characters</h3>
<p>Strings use quotation marks, for example <code>&quot;...&quot;</code>. To include the delimiter itself, repeat it or switch to the explicit form <code>&lt;&quot;...&quot;&gt;</code>. Characters may be written using decimal (<code>\\65</code>), hexadecimal (<code>\\$41</code>), binary (<code>\\%01000001</code>), or predefined character keywords such as <code>\\tab</code>.</p>
<section id="date-and-time"><h3 id="date-and-time">Date and Time</h3>
<p>Date and time values use the <code>@...@</code> form with ISO‑8601 formats. Where implemented, date‑only and time‑only forms may also be parsed.</p>
<section id="null"><h3 id="null">Null</h3>
<p>The <code>?</code> element represents a null value.</p>
<section id="binding-and-reference"><h3 id="binding-and-reference">Binding and Reference</h3>
<p><code>&lt;! let name &lt;value&gt; !&gt;</code> binds <code>name</code> to <code>&lt;value&gt;</code>. Inside subsequent elements the value may be referenced with <code>_name</code> (or inside interpolation as <code>&lt;_name_&gt;</code>).</p>
<p>Batching bindings: The <code>script</code> processing instruction currently supports only the <code>let</code> operator. (Additional operators will be added prior to general release.) You can group several sequential <code>let</code> bindings inside a single tuple so they all execute before the next element parses:</p>
<pre><code class="language-xfer">&lt;! script ( let first &quot;Alice&quot; let greeting 'Hi &lt;_first_&gt;' let answer 42 ) !&gt;
{ message _greeting number _answer }
</code></pre>
<p>All listed <code>let</code> bindings are evaluated in order; later bindings can reference earlier ones (as with <code>_first</code> inside the interpolated greeting) but self‑reference is prevented. Because the script PI here contains only <code>let</code> bindings it does not serialize into the output (it is suppressed after execution).</p>
<section id="interpolated-text"><h3 id="interpolated-text-1">Interpolated Text</h3>
<p>Interpolated text is delimited by apostrophes, for example <code>'Hello &lt;_name_&gt;'</code>. Embedded elements inside must use explicit forms. The expressions are structural replacements, so no character escaping is required.</p>
<section id="dynamic-elements"><h3 id="dynamic-elements">Dynamic Elements</h3>
<p><code>|identifier|</code> resolves through the configured dynamic source resolver (e.g., environment). Content is a single identifier; nested elements are not allowed inside the delimiters in the current implementation.</p>
<section id="processing-instructions-pis"><h3 id="processing-instructions-pis">Processing Instructions (PIs)</h3>
<p>Processing instructions have a compact form <code>! name &lt;value&gt; !</code> and an explicit form <code>&lt;! name &lt;value&gt; !&gt;</code>. Each PI consists of exactly one key/value pair, where the value may be any element. Some PIs introduce bindings or affect subsequent parsing and may be suppressed from serialization after execution.</p>
<hr />
<section id="xferlang-language-specification"><h2 id="xferlang-language-specification">XferLang Language Specification</h2>
<section id="document-structure"><h3 id="document-structure">Document Structure</h3>
<p>The document order is as follows:</p>
<ol>
<li>Zero or more processing instructions.</li>
<li>Exactly one root collection element (Object, Array, or Tuple).</li>
</ol>
<p>Comments (<code>&lt;/ ... /&gt;</code>) may appear anywhere and are ignored by the parser.</p>
<section id="element-syntax-variations"><h3 id="element-syntax-variations">Element Syntax Variations</h3>
<p>XferLang elements have a flexible syntax with up to three variations. This allows you to choose the most readable and concise form for your data, only using more verbose syntax when necessary to resolve ambiguity.</p>
<section id="implicit-syntax"><h4 id="implicit-syntax">Implicit Syntax</h4>
<p>For integers and keywords, no special characters are needed when the context is unambiguous.</p>
<pre><code class="language-xfer">123                 &lt;/ An integer /&gt;
name &quot;Alice&quot;        &lt;/ A key/value pair with implicit keyword 'name' and a string value /&gt;
</code></pre>
<section id="compact-syntax"><h4 id="compact-syntax">Compact Syntax</h4>
<p>Most elements use either a single specifier character or an enclosing pair of specifiers to denote the type. This is the most common syntax. Keywords containing whitespace or other special characters require the <code>=</code> specifier, while identifiers require the <code>:</code> specifier.</p>
<pre><code class="language-xfer">(
    ~true                   &lt;/ A Boolean value /&gt;
    *123.45                 &lt;/ A decimal value /&gt;
    &quot;Hello, World!&quot;         &lt;/ A string /&gt;
    [ #1 #2 #3 ]            &lt;/ An array of integers /&gt;
    =special keyword= #42    &lt;/ A keyword with an embedded space /&gt;
)
</code></pre>
<p>Enclosing specifier characters may be repeated as many times as necessary to enable an element to contain that same specifier character.</p>
<pre><code class="language-xfer">( &quot;&quot;This string contains a &quot; character with impunity.&quot;&quot; )
</code></pre>
<section id="explicit-syntax"><h4 id="explicit-syntax">Explicit Syntax</h4>
<p>When an element's content might be ambiguous (e.g., a string containing a quote), you may wrap the compact form in angle brackets (<code>&lt;</code> and <code>&gt;</code>). This is the most verbose but also the most powerful form, as it affords the most flexibility for containing special characters.</p>
<pre><code class="language-xfer">&lt;(
    &lt;&quot;Alice said, &quot;Boo!&quot;&quot;&gt;
    &lt;// A comment containing &lt;/another comment/&gt; //&gt;
    &lt;=object description=&gt; &lt;&quot;This tuple is inside &lt;()&gt; delimiters.&quot;&gt;
)&gt;
</code></pre>
<hr />
<section id="xferlang-element-reference"><h2 id="xferlang-element-reference">XferLang Element Reference</h2>
<p>XferLang supports a rich set of data types designed for clarity, explicitness, and flexibility. Each type is chosen to represent a distinct kind of value, making data both human-readable and machine-precise.</p>
<section id="primitive-types"><h3 id="primitive-types">Primitive Types</h3>
<section id="string-element"><h4 id="string-element">String Element</h4>
<p>A string element contains text data. The content is stored verbatim. To include a <code>&quot;</code> character that would conflict with the closing delimiter, repeat the specifier (e.g., <code>&quot;&quot;...&quot;&quot;</code>) or use explicit syntax (<code>&lt;&quot;...&quot;&quot;&gt;</code>).</p>
<ul>
<li><p><strong>Specifier:</strong> <code>&quot;</code> (Quotation Mark)</p>
</li>
<li><p><strong>Syntax:</strong></p>
<ul>
<li><strong>Compact:</strong> <code>&quot;Hello, World!&quot;</code></li>
<li><strong>Explicit:</strong> <code>&lt;&quot;Alice said, &quot;Boo!&quot;&quot;&gt;</code></li>
</ul>
</li>
<li><p><strong>Examples:</strong></p>
<pre><code class="language-xfer">&lt;/ Compact syntax /&gt;
message &quot;Hello, World!&quot;

&lt;/ Explicit syntax with quotes /&gt;
quote &lt;&quot;Alice said, &quot;Boo!&quot;&quot;&gt;

&lt;/ Compact syntax with delimiter repetition /&gt;
description &quot;&quot;A quote is a &quot; character.&quot;&quot;
</code></pre>
</li>
</ul>
<section id="character-element"><h4 id="character-element">Character Element</h4>
<p>A character element represents a single UTF-8 character, specified by its codepoint in decimal, hex (<code>$</code>), or binary (<code>%</code>), or by a predefined keyword (e.g., <code>tab</code>, <code>lf</code>, <code>gt</code>).</p>
<ul>
<li><strong>Specifier:</strong> <code>\</code> (Backslash)</li>
<li><strong>Syntax:</strong>
<ul>
<li><strong>Compact:</strong> <code>\65</code>, <code>\$41</code>, <code>\%01000001</code>, <code>\gt</code></li>
<li><strong>Explicit:</strong> <code>&lt;\65\&gt;</code>, <code>&lt;\$41\&gt;</code>, <code>&lt;\gt\&gt;</code></li>
</ul>
</li>
<li><strong>Examples:</strong>
<pre><code class="language-xfer">&lt;/ Compact syntax - decimal codepoint /&gt;
letterA \65

&lt;/ Compact syntax - hex codepoint /&gt;
letterB \$42

&lt;/ Compact syntax - binary codepoint /&gt;
letterC \%01000011

&lt;/ Compact syntax - keyword /&gt;
tabChar \tab
newlineChar \lf

&lt;/ Explicit syntax /&gt;
specialChar &lt;\$2665\&gt;  &lt;/ Heart symbol /&gt;
</code></pre>
</li>
</ul>
<section id="integer-element"><h4 id="integer-element">Integer Element</h4>
<p>An integer element represents a 32-bit signed integer. The value may be written in decimal, hex (<code>$</code>), or binary (<code>%</code>). The specifier is optional if the value is unambiguous (implicit syntax).</p>
<ul>
<li><strong>Specifier:</strong> <code>#</code> (Number Sign)</li>
<li><strong>Syntax:</strong>
<ul>
<li><strong>Implicit:</strong> <code>42</code>, <code>-123</code></li>
<li><strong>Compact:</strong> <code>#42</code>, <code>#$2A</code>, <code>#%-123</code>, <code>#%00101010</code></li>
<li><strong>Explicit:</strong> <code>&lt;#42#&gt;</code>, <code>&lt;#$2A#&gt;</code>, <code>&lt;#%00101010#&gt;</code></li>
</ul>
</li>
<li><strong>Range:</strong> -2,147,483,648 to 2,147,483,647</li>
<li><strong>Examples:</strong>
<pre><code class="language-xfer">&lt;/ Implicit syntax (most common) /&gt;
age 30
count 1000
negative -42

&lt;/ Compact syntax /&gt;
port #8080
timeout #30
colorRed #$FF
permissions #%11110000

&lt;/ Explicit syntax /&gt;
maxValue &lt;#2147483647#&gt;
hexValue &lt;#$DEADBEEF#&gt;
binaryFlags &lt;#%11110000#&gt;
</code></pre>
</li>
</ul>
<section id="long-element"><h4 id="long-element">Long Element</h4>
<p>A long element represents a 64-bit signed integer. The value may be written in decimal, hex (<code>$</code>), or binary (<code>%</code>).</p>
<ul>
<li><strong>Specifier:</strong> <code>&amp;</code> (Ampersand)</li>
<li><strong>Syntax:</strong>
<ul>
<li><strong>Compact:</strong> <code>&amp;5000000000</code>, <code>&amp;$12A05F200</code>, <code>&amp;%1001010100000010111110010000000000</code></li>
<li><strong>Explicit:</strong> <code>&lt;&amp;5000000000&amp;&gt;</code>, <code>&lt;&amp;$12A05F200&amp;&gt;</code>, <code>&lt;&amp;%1001010100000010111110010000000000&amp;&gt;</code></li>
</ul>
</li>
<li><strong>Range:</strong> -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</li>
<li><strong>Examples:</strong>
<pre><code class="language-xfer">&lt;/ Compact syntax /&gt;
population &amp;7800000000
fileSize &amp;5368709120
timestamp &amp;1672531200000

&lt;/ Compact syntax - hexadecimal /&gt;
userId &amp;$1A2B3C4D5E6F
memoryOffset &amp;$7FF6C2E40000

&lt;/ Compact syntax - binary /&gt;
featureFlags &amp;%1111000011110000111100001111

&lt;/ Explicit syntax /&gt;
maxLong &lt;&amp;9223372036854775807&amp;&gt;
hexAddress &lt;&amp;$7FFFFFFFFFFFFFFF&amp;&gt;
binaryMask &lt;&amp;%1111111111111111111111111111111111111111111111111111111111111111&amp;&gt;
</code></pre>
</li>
</ul>
<section id="double-element"><h4 id="double-element">Double Element</h4>
<p>A double element represents a 64-bit floating-point number.</p>
<ul>
<li><strong>Specifier:</strong> <code>^</code> (Caret)</li>
<li><strong>Syntax:</strong>
<ul>
<li><strong>Compact:</strong> <code>^3.14159</code>, <code>^-2.5</code></li>
<li><strong>Explicit:</strong> <code>&lt;^3.14159^&gt;</code>, <code>&lt;^-2.5^&gt;</code></li>
</ul>
</li>
<li><strong>Examples:</strong>
<pre><code class="language-xfer">&lt;/ Compact syntax /&gt;
pi ^3.14159
temperature ^-2.5
radius ^12.75

&lt;/ Explicit syntax /&gt;
preciseValue &lt;^3.141592653589793^&gt;
measurement &lt;^123.456789^&gt;
ratio &lt;^0.618033988749^&gt;
</code></pre>
</li>
</ul>
<section id="decimal-element"><h4 id="decimal-element">Decimal Element</h4>
<p>A decimal element represents a high-precision decimal value.</p>
<ul>
<li><strong>Specifier:</strong> <code>*</code> (Asterisk)</li>
<li><strong>Syntax:</strong>
<ul>
<li><strong>Compact:</strong> <code>*123.45</code>, <code>*-456.789</code>, <code>*0.000001</code></li>
<li><strong>Explicit:</strong> <code>&lt;*123.45*&gt;</code>, <code>&lt;*-456.789*&gt;</code>, <code>&lt;*0.000001*&gt;</code></li>
</ul>
</li>
<li><strong>Examples:</strong>
<pre><code class="language-xfer">&lt;/ Compact syntax /&gt;
price *123.45
balance *-456.789
precision *0.000001

&lt;/ Explicit syntax /&gt;
currency &lt;*1234567.89*&gt;
percentage &lt;*99.999*&gt;
calculation &lt;*0.123456789012345*&gt;
</code></pre>
</li>
</ul>
<section id="boolean-element"><h4 id="boolean-element">Boolean Element</h4>
<p>A Boolean element represents a <code>true</code> or <code>false</code> value.</p>
<ul>
<li><strong>Specifier:</strong> <code>~</code> (Tilde)
<strong>Description:</strong></li>
<li><strong>Syntax:</strong>
<ul>
<li><strong>Compact:</strong> <code>~true</code>, <code>~false</code></li>
<li><strong>Explicit:</strong> <code>&lt;~true~&gt;</code>, <code>&lt;~false~&gt;</code></li>
</ul>
</li>
<li><strong>Examples:</strong>
<pre><code class="language-xfer">&lt;/ Compact syntax /&gt;
isActive ~true
isDeleted ~false
hasPermission ~true

&lt;/ Explicit syntax /&gt;
confirmed &lt;~true~&gt;
disabled &lt;~false~&gt;
verified &lt;~true~&gt;
</code></pre>
</li>
</ul>
<section id="datetime-element"><h4 id="datetime-element">Date/Time Element</h4>
<p>A date/time element represents a date and time value in ISO 8601 format.</p>
<ul>
<li><strong>Specifier:</strong> <code>@</code> (At Sign)</li>
<li><strong>Syntax:</strong>
<ul>
<li><strong>Compact:</strong> <code>@2025-07-23T10:00:00@</code>, <code>@2023-12-25@</code>, <code>@2023-01-01T00:00:00Z@</code></li>
<li><strong>Explicit:</strong> <code>&lt;@2025-07-23T10:00:00@&gt;</code>, <code>&lt;@2023-12-25@&gt;</code>, <code>&lt;@2023-01-01T00:00:00Z@&gt;</code></li>
</ul>
</li>
<li><strong>Examples:</strong>
<pre><code class="language-xfer">&lt;/ Compact syntax /&gt;
created @2023-12-01T10:30:00@
birthDate @1990-05-15@
lastLogin @2023-12-25T09:30:00Z@

&lt;/ Explicit syntax /&gt;
timestamp &lt;@2025-07-23T10:00:00@&gt;
scheduledDate &lt;@2024-01-01T00:00:00Z@&gt;
eventTime &lt;@2023-12-31T23:59:59.999@&gt;
</code></pre>
</li>
</ul>
<section id="null-element"><h4 id="null-element">Null Element</h4>
<p>A null element represents a null value.</p>
<ul>
<li><strong>Specifier:</strong> <code>?</code> (Question Mark)</li>
<li><strong>Syntax:</strong>
<ul>
<li><strong>Compact:</strong> <code>?</code></li>
<li><strong>Explicit:</strong> <code>&lt;??&gt;</code></li>
</ul>
</li>
<li><strong>Examples:</strong>
<pre><code class="language-xfer">&lt;/ Compact syntax /&gt;
optionalValue ?
middleName ?
description ?

&lt;/ Explicit syntax /&gt;
nullField &lt;??&gt;
missingInfo &lt;??&gt;
</code></pre>
</li>
</ul>
<section id="hexadecimal-and-binary-formatting"><h3 id="hexadecimal-and-binary-formatting">Hexadecimal and Binary Formatting</h3>
<p>Integer and Long elements support alternative numeric representations for improved readability in specific contexts:</p>
<p><strong>Hexadecimal Format</strong></p>
<ul>
<li><strong>Syntax:</strong> <code>$</code> prefix followed by hexadecimal digits (e.g., <code>#$2A</code>, <code>&amp;$12A05F200</code>)</li>
<li><strong>Use Cases:</strong> Memory addresses, color values, bitmasks, low-level programming</li>
<li><strong>Parsing:</strong> Case-insensitive (<code>#$2A</code> equals <code>#$2a</code>)</li>
<li><strong>Attributes:</strong> Use <code>[XferNumericFormat(XferNumericFormat.Hexadecimal, MinDigits = 4)]</code> for zero-padding</li>
</ul>
<p><strong>Binary Format</strong></p>
<ul>
<li><strong>Syntax:</strong> <code>%</code> prefix followed by binary digits (e.g., <code>#%101010</code>, <code>&amp;%1001010100000010111110010000000000</code>)</li>
<li><strong>Use Cases:</strong> Bit manipulation, feature flags</li>
<li><strong>Attributes:</strong> Use <code>[XferNumericFormat(XferNumericFormat.Binary, MinBits = 8)]</code> for zero-padding</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-xfer">{
    &lt;/ Decimal integer 42 in different formats /&gt;
    decimal 42
    hex #$2A
    binary #%101010
    padded_hex #$002A
    padded_binary #%00101010
}
</code></pre>
<p>Hexadecimal and binary formatting are only supported for character, integer, and long element types. Decimal and double types preserve fractional precision and do not support these formats.</p>
<section id="collection-elements"><h3 id="collection-elements">Collection Elements</h3>
<section id="object-element"><h4 id="object-element">Object Element</h4>
<p>An object is a collection of key/value pairs. Keys are keyword elements, and values may be any XferLang element.</p>
<ul>
<li><strong>Specifiers:</strong> <code>{</code> and <code>}</code> (Curly Brackets)</li>
<li><strong>Syntax:</strong>
<ul>
<li><strong>Compact:</strong> <code>{ name &quot;Alice&quot; age 30 }</code></li>
<li><strong>Explicit:</strong> <code>&lt;{ name &quot;Alice&quot; age 30 }&gt;</code></li>
</ul>
</li>
<li><strong>Examples:</strong>
<pre><code class="language-xfer">&lt;/ Compact syntax /&gt;
user { name &quot;Alice&quot; age 30 active ~true }
config { host &quot;localhost&quot; port 8080 ssl ~true }

&lt;/ Explicit syntax /&gt;
metadata &lt;{ version &quot;1.0&quot; author &quot;John Doe&quot; }&gt;
settings &lt;{ theme &quot;dark&quot; notifications ~true }&gt;
</code></pre>
</li>
</ul>
<section id="array-element"><h4 id="array-element">Array Element</h4>
<p>An array is a collection of elements of the same type (e.g., all integers, all strings, all objects).</p>
<ul>
<li><strong>Specifiers:</strong> <code>[</code> and <code>]</code> (Square Brackets)</li>
<li><strong>Syntax:</strong>
<ul>
<li><strong>Compact:</strong> <code>[ 1 2 3 ]</code>, <code>[ &quot;a&quot; &quot;b&quot; &quot;c&quot; ]</code></li>
<li><strong>Explicit:</strong> <code>&lt;[ 1 2 3 ]&gt;</code>, <code>&lt;[ &quot;a&quot; &quot;b&quot; &quot;c&quot; ]&gt;</code></li>
</ul>
</li>
<li><strong>Examples:</strong>
<pre><code class="language-xfer">&lt;/ Compact syntax /&gt;
numbers [ 1 2 3 4 5 ]
names [ &quot;Alice&quot; &quot;Bob&quot; &quot;Charlie&quot; ]
booleans [ ~true ~false ~true ]

&lt;/ Explicit syntax /&gt;
ports &lt;[ #80 #443 #8080 ]&gt;
colors &lt;[ &quot;red&quot; &quot;green&quot; &quot;blue&quot; ]&gt;
flags &lt;[ ~true ~true ~false ]&gt;
</code></pre>
</li>
</ul>
<section id="tuple-element"><h4 id="tuple-element">Tuple Element</h4>
<p>A tuple is an ordered collection of elements that may be of <strong>any type</strong>, similar to arrays in JSON. Tuples are ideal for containing heterogeneous data like coordinates, records, or mixed-type sequences.</p>
<ul>
<li><strong>Specifiers:</strong> <code>(</code> and <code>)</code> (Parentheses)</li>
<li><strong>Syntax:</strong>
<ul>
<li><strong>Compact:</strong> <code>( &quot;Alice&quot; 30 ~true )</code></li>
<li><strong>Explicit:</strong> <code>&lt;( &quot;Alice&quot; 30 ~true )&gt;</code></li>
</ul>
</li>
<li><strong>Examples:</strong>
<pre><code class="language-xfer">&lt;/ Compact syntax /&gt;
userRecord ( &quot;John Doe&quot; 30 ~true )
coordinates ( *42.3601 *-71.0589 )
mixedData ( &quot;Sample&quot; @2023-12-25@ *99.5 )

&lt;/ Explicit syntax /&gt;
complexTuple &lt;( &quot;Alice&quot; 30 ~true [ &quot;admin&quot; &quot;user&quot; ] )&gt;
dataPoint &lt;( &quot;Experiment A&quot; @2023-12-01T10:00:00@ *98.7 )&gt;
</code></pre>
</li>
</ul>
<section id="special-purpose-types"><h3 id="special-purpose-types">Special-Purpose Types</h3>
<section id="keyword-element-and-keyvalue-pairs"><h4 id="keyword-element-and-keyvalue-pairs">Keyword Element and Key/Value Pairs</h4>
<p>The key/value pair is the fundamental building block of XferLang objects. The key must be a keyword element, and the value may be any XferLang element. Key-value pairs form the basis of structured data in objects.</p>
<ul>
<li><strong>Specifier:</strong> <code>=</code> (Equal Sign)</li>
<li><strong>Syntax:</strong>
<ul>
<li><strong>Implicit:</strong> <code>name</code>, <code>user_id</code>, <code>isActive</code> (letters, numbers, underscores only - valid only as keys)</li>
<li><strong>Compact:</strong> <code>=first-name=</code>, <code>=email-address=</code>, <code>=API-Key=</code> (keywords as keys with <code>=</code> specifier)</li>
<li><strong>Explicit:</strong> <code>&lt;=first name=&gt;</code>, <code>&lt;=email address=&gt;</code>, <code>&lt;=API Key=&gt;</code> (keywords as keys with explicit syntax)</li>
</ul>
</li>
<li><strong>Examples:</strong></li>
</ul>
<pre><code class="language-xfer">{
    &lt;/ Implicit syntax - only valid as keys /&gt;
    name &quot;Paul&quot;
    age 30
    user_id 12345
    isActive ~true

    &lt;/ Compact syntax for keywords as keys /&gt;
    =first-name= &quot;Alice&quot;
    =last-name= &quot;Johnson&quot;
    =email-address= &quot;user@example.com&quot;

    &lt;/ Explicit syntax for keywords as keys /&gt;
    &lt;=first name=&gt; &quot;Alice&quot;
    &lt;=email address=&gt; &quot;user@example.com&quot;
    &lt;=API Key=&gt; &quot;secret123&quot;
    &lt;=content type=&gt; &quot;application/json&quot;
}
</code></pre>
<p>Key/value pairs may recurse; that is, the value in the key value pair may itself be a key/value pair.</p>
<pre><code class="language-xfer">{
    key1 key2 &quot;key1's value is a key/value pair&quot;
}
</code></pre>
<section id="processing-instruction-element"><h4 id="processing-instruction-element">Processing Instruction Element</h4>
<p>Contains processing instructions for the document, such as the <code>document</code> PI which stores document metadata.</p>
<ul>
<li><strong>Specifier:</strong> <code>!</code> (Exclamation Mark)</li>
<li><strong>Syntax:</strong>
<ul>
<li><strong>Compact:</strong> <code>! document { version &quot;1.0&quot; } !</code></li>
<li><strong>Explicit:</strong> <code>&lt;! document { version &quot;1.0&quot; } !&gt;</code></li>
</ul>
</li>
<li><strong>Examples:</strong></li>
</ul>
<pre><code class="language-xfer">&lt;/ Compact syntax /&gt;
! document { version &quot;1.0&quot; author &quot;John Doe&quot; } !
! id &quot;user-config&quot; !
! chardef { bullet \$2022 arrow \$2192 } !

&lt;/ Explicit syntax /&gt;
&lt;! document { version &quot;1.0&quot; description &quot;Sample document&quot; } !&gt;
&lt;! dynamicSource { username env &quot;USER&quot; } !&gt;
</code></pre>
<section id="comment-element"><h4 id="comment-element">Comment Element</h4>
<p>Comments provide documentation and annotations within XferLang documents. They are ignored during parsing and may be used for explanations, notes, or temporarily disabling content.</p>
<ul>
<li><strong>Specifier:</strong> <code>/</code> (Slash)</li>
<li><strong>Syntax:</strong>
<ul>
<li><strong>Explicit:</strong> <code>&lt;/ comment /&gt;</code>, <code>&lt;// nested &lt;/comment/&gt; via delimiter repetition //&gt;</code></li>
</ul>
</li>
<li><strong>Examples:</strong></li>
</ul>
<pre><code class="language-xfer">&lt;/ Basic comments /&gt;
&lt;/ This is a simple comment /&gt;
&lt;/ Multi-line comment
    spanning several lines /&gt;

&lt;/ Delimiter repetition for nested content /&gt;
&lt;// This comment contains / characters and nested &lt;/comments/&gt; //&gt;
&lt;/// Multi-level nesting for complex content ///&gt;
</code></pre>
<section id="dynamic-element"><h4 id="dynamic-element">Dynamic Element</h4>
<p>Represents a value resolved via the dynamic source pipeline (dynamicSource PI mapping → custom handler → environment fallback).</p>
<ul>
<li><strong>Specifier:</strong> <code>|</code> (Pipe)</li>
<li><strong>Syntax:</strong>
<ul>
<li><strong>Compact:</strong> <code>|USERNAME|</code>, <code>|DB_PASSWORD|</code></li>
<li><strong>Explicit:</strong> <code>&lt;|USERNAME|&gt;</code></li>
</ul>
</li>
<li><strong>Examples:</strong></li>
</ul>
<pre><code class="language-xfer">&lt;/ Compact syntax /&gt;
username |USER|
password |DB_PASSWORD|

&lt;/ Within interpolated strings /&gt;
message 'Hello &lt;|USER|&gt;!'

**Configuration via Processing Instructions:**
```xfer
&lt;! dynamicSource {
    greeting const &quot;Welcome to XferLang&quot; &lt;/ Constant string/&gt;
    username env &quot;USER&quot; &lt;/ Environment variable /&gt;
    config file &quot;settings.xfer&quot; &lt;/ File /&gt;
} !&gt;
{
    message '&lt;|greeting|&gt;' &lt;/ Constant string replaces &lt;|greeting|&gt;. /&gt;
    user '&lt;|username|&gt;' &lt;/ USER environment-variable value replaces &lt;|username|&gt;. /&gt;
    settings '&lt;|config|&gt;' &lt;/ File contents replace &lt;|config|&gt;. /&gt;
}
</code></pre>
<section id="interpolated-string-element"><h4 id="interpolated-string-element">Interpolated String Element</h4>
<p>Interpolated elements render the contents of embedded elements into a string. Otherwise, they are deserialized to a string type just like the string element. Embedded elements must use explicit syntax in order to be evaluated and rendered.</p>
<ul>
<li><strong>Specifier:</strong> <code>'</code> (Apostrophe)</li>
<li><strong>Syntax:</strong>
<ul>
<li><strong>Compact:</strong> <code>'The value is &lt;#42#&gt;'</code>, <code>'Hello, &lt;|NAME|&gt;!'</code></li>
<li><strong>Explicit:</strong> <code>&lt;'The value is &lt;#42#&gt;'&gt;</code>, <code>&lt;'Hello, &lt;|NAME|&gt;!'&gt;</code></li>
</ul>
</li>
<li><strong>Examples:</strong></li>
</ul>
<pre><code class="language-xfer">&lt;/ Compact syntax /&gt;
message 'The value is &lt;#42#&gt;'
greeting 'Hello, &lt;|USERNAME|&gt;!'
template 'User &lt;&quot;Alice&quot;&gt; has &lt;#5#&gt; items'

&lt;/ Explicit syntax /&gt;
complexMessage &lt;'The result is &lt;*99.5*&gt; and status is &lt;~true~&gt;'&gt;
dynamicContent &lt;'Welcome to &lt;|APP_NAME|&gt; version &lt;&quot;1.0&quot;&gt;'&gt;
</code></pre>
<p>It is a good practice to use explicit syntax (<code>&lt;' ... '&gt;</code>) when you are unsure whether interpolated values may contain single quotes.</p>
<section id="reference-element"><h4 id="reference-element">Reference Element</h4>
<p>When the keyword inside a reference element has been bound to an element using the <code>let</code> processing instruction or a <code>let</code> operator inside a <code>script</code> processing instruction, the parser replaces the entire reference element with a clone of the bound element.</p>
<ul>
<li><strong>Specifier:</strong> <code>_</code> (Underscore)</li>
<li><strong>Syntax:</strong>
<ul>
<li><strong>Compact:</strong> <code>_bindingName</code></li>
<li><strong>Explicit:</strong> <code>&lt;_bindingName_&gt;</code></li>
</ul>
</li>
<li><strong>Examples:</strong></li>
</ul>
<pre><code class="language-xfer">&lt;! let host &quot;localhost&quot; !&gt;
{ apiHost _host message 'Host: &lt;_host_&gt;' }
</code></pre>
<section id="common-document-patterns"><h3 id="common-document-patterns">Common Document Patterns</h3>
<p><strong>Configuration Documents</strong>
Most configuration files use Object as the root collection:</p>
<pre><code class="language-xfer">{
    database {
        host &quot;localhost&quot;
        port 5432
        ssl ~true
    }
    logging {
        level &quot;info&quot;
        destinations [ &quot;console&quot; &quot;file&quot; ]
    }
    =cache-timeout= 3600
    =max-connections= 100
}
</code></pre>
<p><strong>Data Collections</strong>
For homogeneous data, use Array as the root:</p>
<pre><code class="language-xfer">[
    { name &quot;Alice&quot; age 30 }
    { name &quot;Bob&quot; age 25 }
    { name &quot;Charlie&quot; age 35 }
]
</code></pre>
<p><strong>Mixed Content Documents</strong>
For documents with heterogeneous top-level content, use Tuple:</p>
<pre><code class="language-xfer">(
    &quot;Document Title&quot;
    @2023-12-25T10:00:00@
    {
        metadata { version &quot;1.0&quot; author &quot;John Doe&quot; }
        content {
            sections [ &quot;intro&quot; &quot;body&quot; &quot;conclusion&quot; ]
            wordCount 1500
        }
    }
)
</code></pre>
<hr />
<section id="complete-examples"><h2 id="complete-examples">Complete Examples</h2>
<p>Here are comprehensive examples showing XferLang in real-world scenarios:</p>
<section id="configuration-file-example"><h3 id="configuration-file-example">Configuration File Example</h3>
<pre><code class="language-xfer">&lt;! document {
    version &quot;1.2&quot;
    author &quot;DevOps Team&quot;
    created @2023-12-01T10:30:00@
    description &quot;Production API configuration&quot;
} !&gt;

{
    server {
        host &quot;api.example.com&quot;
        port 8443
        ssl ~true
        timeout 30
    }

    database {
        primary {
            host &quot;db1.example.com&quot;
            port 5432
            name &quot;production_db&quot;
            ssl ~true
            poolSize 20
        }
        replica {
            host &quot;db2.example.com&quot;
            port 5432
            readOnly ~true
        }
    }

    cache {
        redis {
            nodes [
                { host &quot;cache1.example.com&quot; port 6379 }
                { host &quot;cache2.example.com&quot; port 6379 }
                { host &quot;cache3.example.com&quot; port 6379 }
            ]
            ttl 3600
        }
    }

    logging {
        level &quot;info&quot;
        destinations [ &quot;console&quot; &quot;file&quot; &quot;syslog&quot; ]
    }

    features {
        rateLimiting ~true
        metrics ~true
        debugging ~false
    }
}
</code></pre>
<section id="user-profile-example"><h3 id="user-profile-example">User Profile Example</h3>
<pre><code class="language-xfer">{
    user {
        id &amp;12345678901234
        username &quot;alice_smith&quot;
        email &quot;alice@example.com&quot;

        profile {
            firstName &quot;Alice&quot;
            lastName &quot;Smith&quot;
            birthDate @1990-05-15@
            bio 'Software engineer who loves &lt;\$2615\&gt; and &lt;\$1F4BB\&gt;' &lt;/ coffee and laptop emojis /&gt;
        }

        preferences {
            theme &quot;dark&quot;
            language &quot;en-US&quot;
            timezone &quot;America/New_York&quot;
            notifications {
                email ~true
                push ~false
                sms ~true
            }
        }

        activity {
            lastLogin @2023-12-25T09:30:00Z@
            loginCount #247
            sessions [
                {
                    id &quot;sess_abc123&quot;
                    startTime @2023-12-25T09:30:00Z@
                    ipAddress &quot;192.168.1.100&quot;
                    userAgent &quot;Mozilla/5.0...&quot;
                }
            ]
        }
    }

    addresses [
        {
            type &quot;home&quot;
            street &quot;123 Main Street&quot;
            city &quot;Springfield&quot;
            state &quot;IL&quot;
            zipCode &quot;62702&quot;
            country &quot;US&quot;
            isPrimary ~true
        }
        {
            type &quot;work&quot;
            street &quot;456 Business Ave&quot;
            city &quot;Springfield&quot;
            state &quot;IL&quot;
            zipCode &quot;62702&quot;
            country &quot;US&quot;
            isPrimary ~false
        }
    ]

    lastLogin @2023-12-25T09:30:00Z@
    loginCount #247
}
</code></pre>
<hr />
<section id="the-net-xferlang-library"><h2 id="the.net-xferlang-library">The .NET XferLang Library</h2>
<p>The primary implementation of XferLang is the <code>ParksComputing.Xfer.Lang</code> library for .NET. It provides a comprehensive object model, a robust parser, and a powerful serialization/deserialization utility class, <code>XferConvert</code>.</p>
<section id="getting-started-with-net"><h3 id="getting-started-with.net">Getting Started with .NET</h3>
<p>The XferLang .NET library provides a robust implementation for parsing, generating, and working with XferLang documents programmatically.</p>
<section id="installation"><h4 id="installation">Installation</h4>
<p>Install the <a href="https://www.nuget.org/packages/ParksComputing.Xfer.Lang">NuGet package</a> in your .NET project:</p>
<pre><code class="language-bash">dotnet add package ParksComputing.Xfer.Lang
</code></pre>
<p>Or via Package Manager Console in Visual Studio:</p>
<pre><code class="language-powershell">Install-Package ParksComputing.Xfer.Lang
</code></pre>
<section id="basic-serialization-and-deserialization"><h3 id="basic-serialization-and-deserialization">Basic Serialization and Deserialization</h3>
<pre><code class="language-csharp">using ParksComputing.Xfer.Lang;

// Define a simple class
public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    public bool IsActive { get; set; }
}

// Serialize to XferLang
var person = new Person { Name = &quot;Alice&quot;, Age = 30, IsActive = true };
string xfer = XferConvert.Serialize(person, Formatting.Indented);

Console.WriteLine(xfer);
// Output:
// {
//     Name &quot;Alice&quot;
//     Age 30
//     IsActive ~true
// }

// Deserialize from XferLang
var deserializedPerson = XferConvert.Deserialize&lt;Person&gt;(xfer);
Console.WriteLine($&quot;Name: {deserializedPerson.Name}, Age: {deserializedPerson.Age}&quot;);
</code></pre>
<section id="working-with-collections"><h3 id="working-with-collections">Working with Collections</h3>
<pre><code class="language-csharp">// Arrays and Lists
var numbers = new List&lt;int&gt; { 1, 2, 3, 4, 5 };
string xferArray = XferConvert.Serialize(numbers);
// Result: [ 1 2 3 4 5 ]

// Objects and Dictionaries
var config = new Dictionary&lt;string, object&gt;
{
    [&quot;host&quot;] = &quot;localhost&quot;,
    [&quot;port&quot;] = 8080,
    [&quot;ssl&quot;] = true
};
string xferObject = XferConvert.Serialize(config);
// Result: { host &quot;localhost&quot; port 8080 ssl ~true }
</code></pre>
<section id="advanced-usage-with-xferserializersettings"><h3 id="advanced-usage-with-xferserializersettings">Advanced Usage with <code>XferSerializerSettings</code></h3>
<p>For more control, you may pass an instance of <code>XferSerializerSettings</code> to the <code>Serialize</code> and <code>Deserialize</code> methods.</p>
<section id="null-value-handling"><h4 id="null-value-handling">Null Value Handling</h4>
<p>Properties with <code>null</code> values are included. You may set <code>NullValueHandling</code> to <code>Ignore</code> to omit them.</p>
<pre><code class="language-csharp">var settings = new XferSerializerSettings {
    NullValueHandling = NullValueHandling.Ignore
};
</code></pre>
<section id="customizing-property-names-with-icontractresolver"><h4 id="customizing-property-names-with-icontractresolver">Customizing Property Names with <code>IContractResolver</code></h4>
<p>You may change how property names are serialized by creating a custom contract resolver. For example, to make all property names lowercase:</p>
<pre><code class="language-csharp">public class LowerCaseContractResolver : DefaultContractResolver {
    public override string ResolvePropertyName(string propertyName) {
        return propertyName.ToLower();
    }
}

var settings = new XferSerializerSettings {
    ContractResolver = new LowerCaseContractResolver()
};
</code></pre>
<section id="custom-type-converters-with-ixferconverter"><h4 id="custom-type-converters-with-ixferconverter">Custom Type Converters with <code>IXferConverter</code></h4>
<p>For complete control over how a specific type is handled, you may create a custom converter. This is useful for types that don't map well to standard object serialization or for creating a more compact representation.</p>
<p><strong>Example: A custom converter for a <code>Person</code> class</strong></p>
<pre><code class="language-csharp">// The class to convert
public class Person {
    public string Name { get; set; }
    public int Age { get; set; }
}

// The custom converter
public class PersonConverter : XferConverter&lt;Person&gt; {
    // Convert a Person object to a compact string element
    public override Element WriteXfer(Person value, XferSerializerSettings settings) {
        return new StringElement($&quot;{value.Name},{value.Age}&quot;);
    }

    // Convert a string element back to a Person object
    public override Person ReadXfer(Element element, XferSerializerSettings settings) {
        if (element is StringElement stringElement) {
            var parts = stringElement.Value.Split(',');
            if (parts.Length == 2 &amp;&amp; int.TryParse(parts[1], out int age)) {
                return new Person { Name = parts[0], Age = age };
            }
        }
        throw new InvalidOperationException(&quot;Cannot convert element to Person.&quot;);
    }
}

// How to use it
var settings = new XferSerializerSettings();
settings.Converters.Add(new PersonConverter());

var person = new Person { Name = &quot;John Doe&quot;, Age = 42 };
string xfer = XferConvert.Serialize(person, settings); // Result: &quot;John Doe,42&quot;
</code></pre>
<section id="numeric-formatting-with-attributes"><h4 id="numeric-formatting-with-attributes">Numeric Formatting with Attributes</h4>
<p>The library supports custom numeric formatting for integer and long properties using the <code>XferNumericFormatAttribute</code>. This allows you to control how numeric values are serialized in hexadecimal or binary formats.</p>
<p><strong>Available Formats:</strong></p>
<ul>
<li><code>XferNumericFormat.Decimal</code> - Standard decimal representation (default)</li>
<li><code>XferNumericFormat.Hexadecimal</code> - Hexadecimal with <code>#$</code> prefix</li>
<li><code>XferNumericFormat.Binary</code> - Binary with <code>#%</code> prefix</li>
</ul>
<p><strong>Padding Options:</strong></p>
<ul>
<li><code>MinDigits</code> - For hexadecimal, pads with leading zeros to minimum digit count</li>
<li><code>MinBits</code> - For binary, pads with leading zeros to minimum bit count</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public class ConfigurationData {
    [XferNumericFormat(XferNumericFormat.Decimal)]
    public int Port { get; set; } = 8080;

    [XferNumericFormat(XferNumericFormat.Hexadecimal)]
    public int ColorValue { get; set; } = 0xFF5733;

    [XferNumericFormat(XferNumericFormat.Binary, MinBits = 8)]
    public int Flags { get; set; } = 42;

    [XferNumericFormat(XferNumericFormat.Hexadecimal, MinDigits = 8)]
    public long MemoryAddress { get; set; } = 0x7FF6C2E40000;
}

var config = new ConfigurationData();
string xfer = XferConvert.Serialize(config);
// Result: {Port 8080 ColorValue #$FF5733 Flags #%00101010 MemoryAddress &amp;$7FF6C2E40000}
</code></pre>
<p><strong>Safety Notes:</strong></p>
<ul>
<li>Numeric formatting attributes are only applied to <code>int</code> and <code>long</code> properties</li>
<li><code>decimal</code> and <code>double</code> types ignore formatting attributes to preserve fractional precision</li>
<li>Custom formatting respects the configured <code>ElementStylePreference</code> for syntax style</li>
</ul>
<hr />
<section id="serializer-settings"><h2 id="serializer-settings">Serializer Settings</h2>
<p>For more control over serialization and deserialization, you may use the <code>XferSerializerSettings</code> class. This allows you to configure element styles, null handling, contract resolvers, and custom converters.</p>
<section id="element-style-preferences"><h3 id="element-style-preferences">Element Style Preferences</h3>
<p>Control how elements are serialized using the <code>StylePreference</code> property:</p>
<ul>
<li><strong>Explicit</strong> - Maximum safety, uses angle brackets: <code>&lt;&quot;value&quot;&gt;</code></li>
<li><strong>CompactWhenSafe</strong> - Compact when safe, explicit when necessary: <code>&quot;value&quot;</code> (default)</li>
<li><strong>MinimalWhenSafe</strong> - Most compact form, including implicit syntax for integers</li>
<li><strong>ForceCompact</strong> - Always compact (use with caution)</li>
</ul>
<section id="configuration-example"><h3 id="configuration-example">Configuration Example</h3>
<pre><code class="language-csharp">var settings = new XferSerializerSettings
{
    StylePreference = ElementStylePreference.CompactWhenSafe,
    PreferImplicitSyntax = true,  // Use implicit syntax for integers when safe
    NullValueHandling = NullValueHandling.Ignore,
    ContractResolver = new CustomContractResolver(),
    // ... other settings
};

string xferString = XferConvert.Serialize(user, Formatting.None, settings);
</code></pre>
<section id="available-settings"><h3 id="available-settings">Available Settings</h3>
<ul>
<li><code>StylePreference</code> - Controls element serialization style</li>
<li><code>PreferImplicitSyntax</code> - Use implicit syntax for integers when possible</li>
<li><code>NullValueHandling</code> - How to handle null values (Include/Ignore)</li>
<li><code>ContractResolver</code> - Custom property name resolution</li>
<li><code>Converters</code> - Collection of custom type converters</li>
</ul>
<hr />
<section id="property-attributes"><h2 id="property-attributes">Property Attributes</h2>
<p>The library provides several attributes to control how properties are serialized and deserialized.</p>
<section id="xferpropertyattribute"><h3 id="xferpropertyattribute">XferPropertyAttribute</h3>
<p>The <code>XferPropertyAttribute</code> allows you to customize the property name used in the Xfer document, similar to <code>JsonPropertyName</code> in System.Text.Json.</p>
<pre><code class="language-csharp">public class User
{
    [XferProperty(&quot;user_name&quot;)]
    public string UserName { get; set; }

    [XferProperty(&quot;is_active&quot;)]
    public bool IsActive { get; set; }

    [XferProperty(&quot;created_at&quot;)]
    public DateTime CreatedAt { get; set; }
}

var user = new User
{
    UserName = &quot;alice&quot;,
    IsActive = true,
    CreatedAt = DateTime.UtcNow
};

string xfer = XferConvert.Serialize(user);
// Result: { user_name &quot;alice&quot; is_active ~true created_at @2023-12-25T10:30:00Z@ }
</code></pre>
<section id="xfernumericformatattribute"><h3 id="xfernumericformatattribute">XferNumericFormatAttribute</h3>
<p>The <code>XferNumericFormatAttribute</code> enables custom formatting for integer and long properties, allowing hexadecimal and binary representations with optional padding.</p>
<pre><code class="language-csharp">public class ConfigurationData
{
    [XferNumericFormat(XferNumericFormat.Decimal)]
    public int Port { get; set; } = 8080;

    [XferNumericFormat(XferNumericFormat.Hexadecimal)]
    public int ColorValue { get; set; } = 0xFF5733;

    [XferNumericFormat(XferNumericFormat.Binary, MinBits = 8)]
    public int Flags { get; set; } = 42;

    [XferNumericFormat(XferNumericFormat.Hexadecimal, MinDigits = 8)]
    public long MemoryAddress { get; set; } = 0x7FF6C2E40000;
}

var config = new ConfigurationData();
string xfer = XferConvert.Serialize(config);
// Result: {Port 8080 ColorValue #$FF5733 Flags #%00101010 MemoryAddress &amp;$7FF6C2E40000}
</code></pre>
<section id="xferdecimalprecisionattribute"><h3 id="xferdecimalprecisionattribute">XferDecimalPrecisionAttribute</h3>
<p>The <code>XferDecimalPrecisionAttribute</code> controls the precision and formatting of decimal and double values during serialization, allowing you to specify the maximum number of decimal places and whether to remove trailing zeros.</p>
<pre><code class="language-csharp">public class FinancialData
{
    [XferDecimalPrecision(2)]
    public decimal Price { get; set; } = 123.456789m;

    [XferDecimalPrecision(4, RemoveTrailingZeros = false)]
    public decimal Interest { get; set; } = 5.25m;

    [XferDecimalPrecision(1)]
    public double Temperature { get; set; } = 98.76543;

    [XferDecimalPrecision(0)]
    public decimal Quantity { get; set; } = 150.999m;

    // Without attribute - uses default precision
    public decimal Cost { get; set; } = 99.99999m;
}

var data = new FinancialData();
string xfer = XferConvert.Serialize(data);
// Result: {Price *123.46 Interest *5.2500 Temperature ^98.8 Quantity *151 Cost *99.99999}
</code></pre>
<p><strong>Key Features:</strong></p>
<ul>
<li><strong>Precision Control</strong>: Specify maximum decimal places (0 or greater)</li>
<li><strong>Trailing Zero Handling</strong>: Choose whether to remove trailing zeros (default: true)</li>
<li><strong>Type Support</strong>: Works with both <code>decimal</code> and <code>double</code> properties</li>
<li><strong>Formatting Preservation</strong>: Maintains the appropriate XferLang type specifier (<code>*</code> for decimal, <code>^</code> for double)</li>
</ul>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Financial applications requiring specific decimal precision</li>
<li>Scientific data with controlled significant figures</li>
<li>Display formatting for user interfaces</li>
<li>Data export with consistent decimal representation</li>
</ul>
<section id="safety-notes"><h3 id="safety-notes">Safety Notes</h3>
<ul>
<li>Numeric formatting attributes (<code>XferNumericFormatAttribute</code>) are only applied to <code>int</code> and <code>long</code> properties</li>
<li>Decimal precision attributes (<code>XferDecimalPrecisionAttribute</code>) are only applied to <code>decimal</code> and <code>double</code> properties</li>
<li><code>decimal</code> and <code>double</code> types ignore numeric formatting attributes to preserve fractional precision</li>
<li>Custom formatting respects the configured <code>ElementStylePreference</code> for syntax style</li>
</ul>
<section id="processing-instructions-and-dynamic-content"><h3 id="processing-instructions-and-dynamic-content">Processing Instructions and Dynamic Content</h3>
<p>XferLang supports Processing Instructions (PIs) that provide metadata and configuration for documents. PIs are special elements that control parsing behavior, define document metadata, and enable powerful dynamic content features. The processing-instruction system is fully extensible, allowing you to create custom instructions for specialized use cases.</p>
<section id="built-in-processing-instructions"><h3 id="built-in-processing-instructions">Built-in Processing Instructions</h3>
<p>XferLang includes several built-in PIs that address common document needs:</p>
<section id="document-metadata---document"><h4 id="document-metadata-document">Document Metadata - <code>document</code></h4>
<p>The <code>document</code> processing instruction stores metadata about the XferLang document itself and must appear first if present:</p>
<pre><code class="language-xfer">&lt;! document {
    version &quot;1.0&quot;
    author &quot;John Doe&quot;
    created @2023-12-01T10:30:00@
    description &quot;Sample configuration file&quot;
} !&gt;
{
    // Document content follows...
}
</code></pre>
<p><strong>Key features:</strong></p>
<ul>
<li>Must be the first non-comment element if present</li>
<li>Provides version tracking and document attribution</li>
<li>Supports any metadata fields as key-value pairs</li>
<li>Accessible programmatically through <code>XferDocument.ProcessingInstructions</code></li>
</ul>
<section id="dynamic-element-data-sources---dynamicsource"><h4 id="dynamic-element-data-sources-dynamicsource">Dynamic-Element Data Sources - <code>dynamicSource</code></h4>
<p>The <code>dynamicSource</code> processing instruction configures how dynamic elements <code>&lt;|key|&gt;</code> are resolved, providing flexible runtime value substitution:</p>
<pre><code class="language-xfer">&lt;! dynamicSource {
    greeting const &quot;Welcome to our application&quot;
    username env &quot;USERNAME&quot;
    config file &quot;app.config&quot;
    secret vault &quot;api-key&quot;
} !&gt;
{
    message '&lt;|greeting|&gt;'
    user '&lt;|username|&gt;'
    settings '&lt;|config|&gt;'
    apiKey '&lt;|secret|&gt;'
}
</code></pre>
<section id="custom-character-definitions---chardef"><h4 id="custom-character-definitions-chardef">Custom Character Definitions - <code>chardef</code></h4>
<p>The <code>chardef</code> processing instruction allows you to define custom character aliases for use in character elements:</p>
<pre><code class="language-xfer">&lt;! chardef {
    bullet \$2022
    arrow \$2192
    check \$2713
} !&gt;
{
    symbols [ \bullet \arrow \check ]
}
</code></pre>
<section id="element-id---id"><h4 id="element-id-id">Element ID - <code>id</code></h4>
<p>The <code>id</code> processing instruction assigns identifiers to elements for referencing and linking:</p>
<pre><code class="language-xfer">{
    &lt;! id &quot;user-config&quot; !&gt;
    section {
        name &quot;User Settings&quot;
        enabled ~true
    }
}
</code></pre>
<section id="element-tagging---tag"><h4 id="element-tagging-tag">Element Tagging - <code>tag</code></h4>
<p>The <code>tag</code> processing instruction attaches free‑form classification metadata to the immediately following element. Multiple <code>tag</code> processing instructions may be stacked; tags are preserved in element metadata but have no built‑in semantic effect.</p>
<pre><code class="language-xfer">&lt;! tag &quot;experimental&quot; !&gt;
&lt;! tag &quot;search-index&quot; !&gt;
feature { enabled ~true }
</code></pre>
<section id="conditional-element-parsing-and-output---if-defined"><h4 id="conditional-element-parsing-and-output-if-defined">Conditional Element Parsing and Output - <code>if defined</code></h4>
<p>The <code>if defined</code> processing instruction evaluates whether its value element yields a meaningful value (non‑null / non‑empty). When the value is defined, the associated content is parsed and output; otherwise, it is skipped.</p>
<pre><code class="language-xfer">&lt;! let debug ~false !&gt;
&lt;! if defined _debug !&gt;
{ note 'debug binding exists' }

&lt;! dynamicSource { optFlag env &quot;OPTIONAL_FLAG&quot; } !&gt;
&lt;! if defined &lt;|optFlag|&gt; !&gt;
{ note 'OPTIONAL_FLAG present' }
</code></pre>
<p>Evaluation occurs during processing-instruction processing; the processing instruction itself is suppressed from serialization.</p>
<section id="dynamic-elements-and-source-resolution"><h3 id="dynamic-elements-and-source-resolution">Dynamic Elements and Source Resolution</h3>
<p>Dynamic elements provide runtime value substitution with an extensible source system.</p>
<section id="built-in-source-types"><h4 id="built-in-source-types">Built-in Source Types</h4>
<p>XferLang includes three built-in source handlers:</p>
<p><strong>Constant Sources (<code>const</code>)</strong></p>
<ul>
<li>Returns the configured value as a literal constant</li>
<li>Useful for templating and configuration management</li>
<li>Example: <code>greeting const &quot;Hello, World!&quot;</code></li>
</ul>
<p><strong>Environment Variables (<code>env</code>)</strong></p>
<ul>
<li>Reads from system environment variables</li>
<li>Supports fallback values and variable name mapping</li>
<li>Example: <code>username env &quot;USER&quot;</code> (reads from $USER environment variable)</li>
</ul>
<p><strong>File Sources (<code>file</code>)</strong></p>
<ul>
<li>Reads content from files at parse time</li>
<li>Supports relative and absolute paths</li>
<li>Example: <code>config file &quot;settings.json&quot;</code></li>
</ul>
<section id="custom-source-handler-registration"><h4 id="custom-source-handler-registration">Custom Source Handler Registration</h4>
<p>You may extend the dynamic-source handler with custom source types for databases, web services, or other data sources:</p>
<pre><code class="language-csharp">// Register a custom 'vault' source handler
DynamicSourceHandlerRegistry.RegisterHandler(&quot;vault&quot;, (sourceValue, fallbackKey) =&gt; {
    var key = sourceValue ?? fallbackKey;
    return await SecretVaultClient.GetSecretAsync(key);
});

// Register a database source handler
DynamicSourceHandlerRegistry.RegisterHandler(&quot;db&quot;, (sourceValue, fallbackKey) =&gt; {
    var query = sourceValue ?? $&quot;SELECT value FROM config WHERE key = '{fallbackKey}'&quot;;
    return DatabaseService.ExecuteScalar(query);
});
</code></pre>
<p><strong>Resolution Priority:</strong></p>
<ol>
<li>Configured source type in <code>dynamicSource</code> PI</li>
<li>Fallback to environment variables</li>
<li>Return empty string if not found</li>
</ol>
<section id="extending-processing-instructions"><h3 id="extending-processing-instructions">Extending Processing Instructions</h3>
<p>The PI system is designed for extensibility, allowing you to create custom instructions for specialized parsing and document processing needs.</p>
<section id="creating-custom-pis"><h4 id="creating-custom-pis">Creating Custom PIs</h4>
<p>To create a custom PI, inherit from <code>ProcessingInstruction</code> and implement the required behavior:</p>
<pre><code class="language-csharp">public class ValidationProcessingInstruction : ProcessingInstruction {
    public const string Keyword = &quot;validation&quot;;

    public ValidationProcessingInstruction(ObjectElement rules) : base(rules, Keyword) { }

    public override void ProcessingInstructionHandler() {
        if (Value is not ObjectElement obj) {
            throw new InvalidOperationException($&quot;{Keyword} PI expects an object element&quot;);
        }

        // Process validation rules and store globally
        foreach (var kv in obj.Dictionary) {
            var fieldName = kv.Value.Key;
            var rules = kv.Value.Value;
            ValidationRegistry.RegisterRules(fieldName, rules);
        }
    }

    public override void ElementHandler(Element element) {
        // Apply validation rules to specific elements
        ValidationRegistry.ValidateElement(element);
    }
}
</code></pre>
<section id="pi-registration-and-lifecycle"><h4 id="pi-registration-and-lifecycle">PI Registration and Lifecycle</h4>
<p>Register custom PIs with the parser during initialization:</p>
<pre><code class="language-csharp">// Register the custom PI processor
Parser.RegisterPIProcessor(ValidationProcessingInstruction.Keyword,
    (kvp, parser) =&gt; new ValidationProcessingInstruction((ObjectElement)kvp.Value));

// Example usage in XferLang document
var xferContent = @&quot;
&lt;! validation {
    userEmail regex &quot;&quot;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$&quot;&quot;
    userAge range { min 0 max 120 }
} !&gt;
{
    userEmail &quot;&quot;user@example.com&quot;&quot;
    userAge 25
}&quot;;
</code></pre>
<p><strong>Processing-Instruction Lifecycle:</strong></p>
<ol>
<li><strong>Discovery</strong>: PIs are identified during metadata parsing</li>
<li><strong>Creation</strong>: Registered processors create PI instances</li>
<li><strong>Processing</strong>: <code>ProcessingInstructionHandler()</code> is called for document-level setup</li>
<li><strong>Element Processing</strong>: <code>ElementHandler()</code> is called for each relevant element</li>
<li><strong>Cleanup</strong>: PIs may register cleanup logic if needed</li>
</ol>
<p><strong>Advanced Features:</strong></p>
<ul>
<li><strong>Scoped PIs</strong>: Apply to specific document sections</li>
<li><strong>Cascading PIs</strong>: Inherit behavior from parent elements</li>
<li><strong>Conditional PIs</strong>: Activate based on document content or external conditions</li>
<li><strong>Multi-phase PIs</strong>: Process elements in multiple passes</li>
</ul>
<p>This extensible PI system makes XferLang highly adaptable for domain-specific needs, from configuration management to data validation and transformation pipelines.</p>
<section id="writing-custom-processing-instructions"><h3 id="writing-custom-processing-instructions">Writing Custom Processing Instructions</h3>
<p>You may add new Processing Instruction (PI) keywords without modifying the core parser by registering a factory that creates a <code>ProcessingInstruction</code> subclass. This lets you introduce custom metadata, validation passes, conditional logic, or side‑effects at parse time.</p>
<section id="when-to-create-a-pi"><h3 id="when-to-create-a-pi">When to Create a PI</h3>
<p>Create a PI when you need to:</p>
<ul>
<li>Run setup logic before the next element is parsed (<code>ProcessingInstructionHandler</code>).</li>
<li>Optionally suppress or transform the immediately following element (<code>ElementHandler</code>).</li>
<li>Carry operational intent that should not appear in serialized output (set <code>SuppressSerialization = true</code>).</li>
</ul>
<p>Do NOT create a PI just to change how <code>|dynamic|</code> values resolve—use a custom <code>IDynamicSourceResolver</code> for that (see &quot;Dynamic Elements and Source Resolution&quot;).</p>
<section id="parser-registration-model"><h3 id="parser-registration-model">Parser Registration Model</h3>
<p>The parser exposes two overloads of <code>RegisterPIProcessor</code>:</p>
<pre><code class="language-csharp">// (1) Low-level: attach raw callbacks for existing PIs
void RegisterPIProcessor(string key, Action&lt;KeyValuePairElement&gt; processor);

// (2) Factory: create a strongly-typed ProcessingInstruction instance
void RegisterPIProcessor(string key, Parser.PIProcessor factory); // factory: (kvp, parser) =&gt; ProcessingInstruction
</code></pre>
<p>Built‑ins are installed via the factory form inside <code>RegisterBuiltInPIProcessors()</code>.</p>
<section id="minimal-custom-pi-example-trace"><h3 id="minimal-custom-pi-example-trace">Minimal Custom PI Example (<code>trace</code>)</h3>
<pre><code class="language-csharp">public sealed class TraceProcessingInstruction : ProcessingInstruction {
    public const string Keyword = &quot;trace&quot;;
    public TraceProcessingInstruction(Element value) : base(value, Keyword) {
        SuppressSerialization = true; // operational only
    }
    public override void ProcessingInstructionHandler() {
        Console.WriteLine($&quot;[TRACE-PI] {Value}&quot;);
    }
}

static ProcessingInstruction CreateTracePI(KeyValuePairElement kvp, Parser p) =&gt;
    new TraceProcessingInstruction(kvp.Value);

var parser = new Parser();
parser.RegisterPIProcessor(TraceProcessingInstruction.Keyword, CreateTracePI);
</code></pre>
<p>Usage:</p>
<pre><code class="language-xfer">&lt;! trace &quot;Starting build&quot; !&gt;
{ pipeline { stage &quot;compile&quot; } }
</code></pre>
<section id="conditioning-the-next-element"><h3 id="conditioning-the-next-element">Conditioning the Next Element</h3>
<p>To influence the element that immediately follows the PI, override <code>ElementHandler</code>. Pattern (see <code>IfProcessingInstruction</code> in source):</p>
<pre><code class="language-csharp">public override void ElementHandler(Element element) {
    if (!ShouldKeep(element)) {
        // Throw the same suppression exception style used by built-ins if you want to remove it
        throw new ConditionalElementException(&quot;Suppressed by custom PI&quot;);
    }
}
</code></pre>
<section id="validation-pi-skeleton"><h3 id="validation-pi-skeleton">Validation PI Skeleton</h3>
<pre><code class="language-csharp">public sealed class ValidationProcessingInstruction : ProcessingInstruction {
    public const string Keyword = &quot;validation&quot;;
    public ValidationProcessingInstruction(ObjectElement value) : base(value, Keyword) {
        SuppressSerialization = true;
    }
    public override void ProcessingInstructionHandler() {
        if (Value is not ObjectElement obj) throw new InvalidOperationException(&quot;validation PI expects object value&quot;);
        foreach (var kv in obj.Dictionary.Values) {
            var field = kv.Key;
            var ruleSpec = kv.Value;
            ValidationRegistry.Register(field, ruleSpec);
        }
    }
    public override void ElementHandler(Element element) =&gt; ValidationRegistry.Validate(element);
}

static ProcessingInstruction CreateValidationPI(KeyValuePairElement kvp, Parser p) =&gt;
    new ValidationProcessingInstruction((ObjectElement)kvp.Value);

parser.RegisterPIProcessor(ValidationProcessingInstruction.Keyword, CreateValidationPI);
</code></pre>
<section id="extending-dynamic-resolution-no-new-pi-required"><h3 id="extending-dynamic-resolution-no-new-pi-required">Extending Dynamic Resolution (No New PI Required)</h3>
<p>If you just need custom resolution for <code>|key|</code>, implement a resolver:</p>
<pre><code class="language-csharp">public class MyDynamicSourceResolver : DefaultDynamicSourceResolver {
    public override string? Resolve(string key) =&gt; key == &quot;special&quot; ? &quot;custom-value&quot; : base.Resolve(key);
}
var settings = new XferSerializerSettings { DynamicSourceResolver = new MyDynamicSourceResolver() };
</code></pre>
<section id="checklist-for-a-new-pi"><h3 id="checklist-for-a-new-pi">Checklist for a New PI</h3>
<ol>
<li>Define a constant <code>Keyword</code>.</li>
<li>Subclass <code>ProcessingInstruction</code>.</li>
<li>(Optional) Set <code>SuppressSerialization</code> in constructor.</li>
<li>Override <code>ProcessingInstructionHandler</code> for one-time setup.</li>
<li>Override <code>ElementHandler</code> if you must inspect or suppress the following element.</li>
<li>Register a factory with <code>parser.RegisterPIProcessor(Keyword, Factory)</code>.</li>
<li>Add tests covering: creation, handler execution order, suppression (if any), serialization visibility.</li>
</ol>
<section id="lifecycle-summary"><h3 id="lifecycle-summary">Lifecycle Summary</h3>
<ol>
<li>Parser encounters <code>&lt;! keyword value !&gt;</code>.</li>
<li>Registered factory creates PI instance.</li>
<li>Parser calls <code>ProcessingInstructionHandler()</code> immediately.</li>
<li>When the next element is parsed, <code>ElementHandler()</code> runs (if overridden).</li>
<li>PI may be omitted from serialization if <code>SuppressSerialization</code> is true.</li>
</ol>
<p>This model keeps the core grammar stable while enabling domain‑specific behaviors.</p>
<hr />
<section id="building-xferlang"><h2 id="building-xferlang">Building XferLang</h2>
<p>Information for developers who want to build XferLang from source or contribute to the project.</p>
<section id="prerequisites"><h3 id="prerequisites">Prerequisites</h3>
<ul>
<li><strong>.NET SDK 8.0 or later</strong> - <a href="https://dotnet.microsoft.com/download">Download from Microsoft</a></li>
<li><strong>Git</strong> - For cloning the repository</li>
</ul>
<section id="quick-start"><h3 id="quick-start">Quick Start</h3>
<pre><code class="language-bash"># Clone the repository
git clone https://github.com/paulmooreparks/Xfer.git
cd Xfer

# Build the entire solution
dotnet build

# Run the tests
dotnet test

# Create NuGet packages (optional)
dotnet pack --configuration Release
</code></pre>
<section id="project-structure"><h3 id="project-structure">Project Structure</h3>
<p>The XferLang solution contains several projects and folders:</p>
<ul>
<li><strong>ParksComputing.Xfer.Lang</strong> - Main library</li>
<li><strong>ParksComputing.Xfer.Lang.Tests</strong> - Unit tests and integration tests</li>
<li><strong>XferService</strong> - Example web service implementation (optional)</li>
<li><strong>XferDocBuilder</strong> - Custom tool for generating documentation</li>
<li><strong>examples</strong> - Command-line examples demonstrating various uses of XferLang</li>
<li><strong>tools</strong> - Development tools and utilities</li>
</ul>
<section id="development-commands"><h3 id="development-commands">Development Commands</h3>
<pre><code class="language-bash"># Build in Debug mode
dotnet build --configuration Debug

# Build in Release mode
dotnet build --configuration Release

# Run tests with verbose output
dotnet test --verbosity normal

# Run tests with code coverage
dotnet test --collect:&quot;XPlat Code Coverage&quot;
</code></pre>
<hr />
<section id="community-and-resources"><h2 id="community-and-resources">Community and Resources</h2>
<p>Join the XferLang community and access helpful resources for learning and development.</p>
<section id="learning-resources"><h3 id="learning-resources">Learning Resources</h3>
<ul>
<li>📖 <strong>Documentation:</strong> <a href="https://xferlang.org/">This comprehensive guide</a></li>
<li>🎯 <strong>Examples:</strong> <a href="https://github.com/paulmooreparks/Xfer/tree/master/examples">Sample XferLang applications</a> in the repository</li>
<li>💡 <strong>Tests:</strong> <a href="https://github.com/paulmooreparks/Xfer/tree/master/ParksComputing.Xfer.Lang.Tests">Unit Tests</a> also show how to use the library and provide test coverage</li>
<li>📄 <strong>Sample Documents:</strong> <a href="https://github.com/paulmooreparks/Xfer/tree/master">*.xfer files</a> in the repository</li>
</ul>
<section id="getting-help"><h3 id="getting-help">Getting Help</h3>
<ul>
<li>❓ <strong>Questions:</strong> Open a <a href="https://github.com/paulmooreparks/Xfer/discussions">GitHub Discussion</a></li>
<li>🐛 <strong>Bug Reports:</strong> Create an <a href="https://github.com/paulmooreparks/Xfer/issues">Issue</a> with details</li>
<li>💡 <strong>Feature Requests:</strong> Suggest improvements via <a href="https://github.com/paulmooreparks/Xfer/issues">GitHub Issues</a></li>
<li>📧 <strong>Direct Contact:</strong> Reach out via GitHub for complex questions</li>
</ul>
<hr />
<section id="contributing"><h2 id="contributing">Contributing</h2>
<p>This is an open-source project, and contributions are always welcome! If you are interested in helping, please feel free to open an issue or a pull request on <a href="https://github.com/paulmooreparks/Xfer">GitHub</a>. You may also reach out to me directly via email at <a href="mailto:paul@parkscomputing.com">paul@parkscomputing.com</a>.</p>
<hr />
<section id="grammar"><h2 id="grammar">Grammar</h2>
<p>The formal Backus–Naur form (BNF) grammar for XferLang can be found in the XferLang GitHub repository: <a href="https://github.com/paulmooreparks/Xfer/blob/master/xfer.bnf">xfer.bnf</a>.</p>
</section>

        <footer>
            <p>Documentation generated on 2025-08-13 13:01:18 UTC</p>
        </footer>
    </main>
    <script>hljs.highlightAll();</script>
</body>
</html>
