<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XferLang Documentation</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="highlightjs/styles/github.min.css">
    <script src="highlightjs/highlight.min.js"></script>
    <script src="highlightjs/languages/xfer.min.js"></script>
</head>
<body>
    <div class="mobile-nav-toggle">
        ☰
    </div>
    <nav class="sidebar">
        <div class="sidebar-header">
            <h2><a href="index.html" class="home-link">XferLang</a></h2>
        </div>
        <ul>
            <li><a href="#introduction-and-philosophy">Introduction and Philosophy</a></li>
            <li><a href="#xferlang-by-example">XferLang by Example</a></li>
            <li>
                <details>
                    <summary>Language Specification</summary>
                    <ul>
                <li><a href="#document-structure">Document Structure</a></li>
                <li><a href="#element-syntax-variations">Element Syntax Variations</a></li>
                <li><a href="#element-reference">Element Reference</a></li>
                <li><a href="#document-validation-and-common-mistakes">Document Validation and Common Mistakes</a></li>
                    </ul>
                </details>
            </li>
            <li>
                <details>
                    <summary>The .NET XferLang Library</summary>
                    <ul>
                <li><a href="#basic-serialization-andamp-deserialization">Basic Serialization &amp; Deserialization</a></li>
                <li><a href="#advanced-usage-with-xferserializersettings">Advanced Usage with XferSerializerSettings</a></li>
                    </ul>
                </details>
            </li>
            <li>
                <details>
                    <summary>Processing Instructions &amp; Dynamic Content</summary>
                    <ul>
                <li><a href="#built-in-processing-instructions">Built-in Processing Instructions</a></li>
                <li><a href="#dynamic-elements-andamp-source-resolution">Dynamic Elements &amp; Source Resolution</a></li>
                <li><a href="#extending-processing-instructions">Extending Processing Instructions</a></li>
                    </ul>
                </details>
            </li>
            <li><a href="#project-status-andamp-roadmap">Project Status &amp; Roadmap</a></li>
            <li><a href="#contributing">Contributing</a></li>
            <li><a href="#grammar">Grammar</a></li>
        </ul>

    </nav>
    <main class="content">

<p><img src="https://raw.githubusercontent.com/paulmooreparks/Xfer/master/logo/XferLang-sm.png" alt="XferLogo" /></p>
<h1 id="the-xferlang-data-interchange-format">The XferLang Data-Interchange Format</h1>
<p><a href="https://github.com/paulmooreparks/Xfer/actions/workflows/dotnet.yml"><img src="https://github.com/paulmooreparks/Xfer/actions/workflows/dotnet.yml/badge.svg" alt=".NET Build Status" /></a>
<a href="https://www.nuget.org/packages/ParksComputing.Xfer.Lang"><img src="https://img.shields.io/nuget/vpre/ParksComputing.Xfer.Lang.svg" alt="NuGet" /></a>
<a href="https://github.com/paulmooreparks/Xfer"><img src="https://img.shields.io/github/last-commit/paulmooreparks/Xfer" alt="GitHub last commit" /></a>
<a href="https://github.com/paulmooreparks/Xfer/issues"><img src="https://img.shields.io/github/issues/paulmooreparks/Xfer" alt="GitHub issues" /></a>
<a href="https://opensource.org/licenses/MIT"><img src="https://img.shields.io/badge/License-MIT-yellow.svg" alt="License: MIT" /></a></p>
<p><em>Welcome to everyone who came here from <a href="https://news.ycombinator.com/item?id=42114543">Hacker News</a>. Thank you so much for all the great input and discussion!</em></p>
<section id="table-of-contents"><h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#the-xferlang-data-interchange-format">The XferLang Data-Interchange Format</a>
<ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#introduction-and-philosophy">Introduction and Philosophy</a></li>
<li><a href="#xferlang-by-example">XferLang by Example</a></li>
<li><a href="#language-specification">Language Specification</a>
<ul>
<li><a href="#document-structure">Document Structure</a></li>
<li><a href="#element-syntax-variations">Element Syntax Variations</a>
<ul>
<li><a href="#implicit-syntax">Implicit Syntax</a></li>
<li><a href="#compact-syntax">Compact Syntax</a></li>
<li><a href="#explicit-syntax">Explicit Syntax</a></li>
</ul>
</li>
<li><a href="#element-reference">Element Reference</a>
<ul>
<li><a href="#primitive-types">Primitive Types</a></li>
<li><a href="#hexadecimal-and-binary-formatting">Hexadecimal and Binary Formatting</a></li>
<li><a href="#structural-types">Structural Types</a></li>
<li><a href="#common-document-patterns">Common Document Patterns</a></li>
<li><a href="#special-purpose-types">Special-Purpose Types</a></li>
</ul>
</li>
<li><a href="#document-validation-and-common-mistakes">Document Validation and Common Mistakes</a></li>
</ul>
</li>
<li><a href="#the-net-xferlang-library">The <code>.NET XferLang Library</code></a>
<ul>
<li><a href="#basic-serialization--deserialization">Basic Serialization &amp; Deserialization</a></li>
<li><a href="#advanced-usage-with-xferserializersettings">Advanced Usage with <code>XferSerializerSettings</code></a>
<ul>
<li><a href="#null-value-handling">Null Value Handling</a></li>
<li><a href="#customizing-property-names-with-icontractresolver">Customizing Property Names with <code>IContractResolver</code></a></li>
<li><a href="#custom-type-converters-with-ixferconverter">Custom Type Converters with <code>IXferConverter</code></a></li>
<li><a href="#numeric-formatting-with-attributes">Numeric Formatting with Attributes</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#processing-instructions--dynamic-content">Processing Instructions &amp; Dynamic Content</a>
<ul>
<li><a href="#built-in-processing-instructions">Built-in Processing Instructions</a>
<ul>
<li><a href="#document-metadata-pi">Document Metadata PI</a></li>
<li><a href="#dynamicsource-pi">DynamicSource PI</a></li>
<li><a href="#chardef-pi">CharDef PI</a></li>
<li><a href="#id-pi">ID PI</a></li>
</ul>
</li>
<li><a href="#dynamic-elements--source-resolution">Dynamic Elements &amp; Source Resolution</a>
<ul>
<li><a href="#built-in-source-types">Built-in Source Types</a></li>
<li><a href="#custom-source-handler-registration">Custom Source Handler Registration</a></li>
</ul>
</li>
<li><a href="#extending-processing-instructions">Extending Processing Instructions</a>
<ul>
<li><a href="#creating-custom-pis">Creating Custom PIs</a></li>
<li><a href="#pi-registration--lifecycle">PI Registration &amp; Lifecycle</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#project-status--roadmap">Project Status &amp; Roadmap</a></li>
<li><a href="#contributing">Contributing</a></li>
<li><a href="#grammar">Grammar</a></li>
</ul>
</li>
</ul>
<section id="introduction-and-philosophy"><h2 id="introduction-and-philosophy">Introduction and Philosophy</h2>
<p>XferLang is a data-interchange format designed to support data serialization, data transmission, and offline use cases such as configuration management. Its design philosophy is centered around four key principles:</p>
<ul>
<li><strong>Clarity and Readability</strong>: The syntax is designed to be human-readable, even without separators like commas. This is achieved by using whitespace to delimit elements in most cases.</li>
<li><strong>Explicit Typing</strong>: All values are explicitly typed. This avoids the type ambiguity that can sometimes occur in formats like JSON, leading to more predictable parsing and less defensive coding.</li>
<li><strong>Elimination of Escaping</strong>: XferLang does not require escaping of special characters in values. Instead, values are enclosed in unique delimiters. If the content contains a sequence that matches the delimiter, the delimiter character can be repeated as many times as necessary to make it unique, ensuring that data can be embedded without modification.</li>
<li><strong>Safety in Embedding</strong>: The delimiter-repetition strategy allows for the safe embedding of complex, nested data structures without the risk of delimiter collision.</li>
<li><strong>Structured Root</strong>: All XferLang documents require a root collection element (Object, Array, or Tuple) to ensure well-defined document structure and unambiguous parsing.</li>
</ul>
<section id="xferlang-by-example"><h2 id="xferlang-by-example">XferLang by Example</h2>
<p>Perhaps the easiest way to understand XferLang is to see it compared to a familiar format like JSON.</p>
<p>Here's a simple XferLang document:</p>
<pre><code class="language-xfer">{
    name &quot;Alice&quot;
    age 30
    isMember ~true
    scores [*85 *90 *78.5]
    profile {
        email &quot;alice@example.com&quot;
        joinedDate @2023-01-15T12:00:00@
    }
}
</code></pre>
<p>And here is the equivalent JSON document:</p>
<pre><code class="language-json">{
    &quot;name&quot;: &quot;Alice&quot;,
    &quot;age&quot;: 30,
    &quot;isMember&quot;: true,
    &quot;scores&quot;: [85, 90, 78.5],
    &quot;profile&quot;: {
        &quot;email&quot;: &quot;alice@example.com&quot;,
        &quot;joinedDate&quot;: &quot;2023-01-15T12:00:00&quot;
    }
}
</code></pre>
<p>In contrast to JSON, XferLang eliminates commas, uses explicit type prefixes for certain types (<code>*</code> for decimal, <code>~</code> for Boolean, <code>?</code> for null) while maintaining readability.</p>
<p>Because whitespace is flexible, the same XferLang document can be made extremely compact:</p>
<pre><code class="language-xfer">{name&quot;Alice&quot;age 30 isMember~true scores[*85*90*78.5]profile{email&quot;alice@example.com&quot;joinedDate@2023-05-05T20:00:00@}}
</code></pre>
<section id="language-specification"><h2 id="language-specification">Language Specification</h2>
<section id="document-structure"><h3 id="document-structure">Document Structure</h3>
<p>An XferLang document consists of two main parts: an optional <strong>Metadata Element</strong> followed by a <strong>Root Collection Element</strong>.</p>
<ul>
<li><strong>Metadata Element</strong>: If present, this must be the very first non-comment element in the document. It is used to store information about the document itself, such as the XferLang version.</li>
<li><strong>Root Collection Element</strong>: The main content of the document must be contained within a single collection element (Object, Array, or Tuple). This ensures the document has a well-defined structure and prevents ambiguity in parsing.</li>
</ul>
<pre><code class="language-xfer">&lt;/ A document metadata element, which is signified with the reserved keyword `document` is optional, but if present it must be the first element in the document. /&gt;
&lt;! document { version &quot;1.0&quot; } !&gt;

&lt;/ The document content must be wrapped in a collection element /&gt;
{
    message &quot;Hello, World!&quot;
    count 42
    config { debug ~true }
}
</code></pre>
<p><strong>Valid Root Collection Types:</strong></p>
<ul>
<li><strong>Object</strong>: <code>{ key1 value1 key2 value2 }</code> - Most common for structured data</li>
<li><strong>Array</strong>: <code>[ element1 element2 element3 ]</code> - For homogeneous collections</li>
<li><strong>Tuple</strong>: <code>( element1 element2 element3 )</code> - For heterogeneous sequences</li>
</ul>
<section id="element-syntax-variations"><h3 id="element-syntax-variations">Element Syntax Variations</h3>
<p>XferLang elements have a flexible syntax with up to three variations. This allows you to choose the most readable and concise form for your data, only using more verbose syntax when necessary to resolve ambiguity.</p>
<section id="implicit-syntax"><h4 id="implicit-syntax">Implicit Syntax</h4>
<p>For the most common types, like integers and simple keywords, no special characters are needed at all. The parser infers the type from the content.</p>
<pre><code class="language-xfer">123                 &lt;/ An integer /&gt;
name &quot;Alice&quot;        &lt;/ A key/value pair of a keyword 'name' and a string value /&gt;
</code></pre>
<section id="compact-syntax"><h4 id="compact-syntax">Compact Syntax</h4>
<p>For most other types, a single specifier character (or a pair for collections) denotes the type. This is the most common syntax.</p>
<pre><code class="language-xfer">~true               &lt;/ A boolean /&gt;
*123.45             &lt;/ A decimal /&gt;
&quot;Hello, World!&quot;     &lt;/ A string /&gt;
[ 1 2 3 ]           &lt;/ An array of integers /&gt;
</code></pre>
<section id="explicit-syntax"><h4 id="explicit-syntax">Explicit Syntax</h4>
<p>When an element's content might be ambiguous (e.g., a string containing a quote), you can wrap the compact form in angle brackets (<code>&lt;</code> and <code>&gt;</code>). This is the most verbose but also the most powerful form, as it allows for delimiter repetition to avoid any collision.</p>
<pre><code class="language-xfer">&lt;&quot;Alice said, &quot;Boo!&quot;&quot;&gt;
&lt;// A comment containing &lt;/another comment/&gt; //&gt;
</code></pre>
<section id="element-reference"><h3 id="element-reference">Element Reference</h3>
<p>This section provides a detailed reference for each XferLang element type.</p>
<section id="primitive-types"><h4 id="primitive-types">Primitive Types</h4>
<p><strong>String Element</strong></p>
<ul>
<li><strong>Specifier:</strong> <code>&quot;</code> (Quotation Mark)</li>
<li><strong>Description:</strong> Contains text data. The content is stored verbatim. To include a <code>&quot;</code> character that would conflict with the closing delimiter, repeat the specifier (e.g., <code>&quot;&quot;...&quot;&quot;</code>) or use explicit syntax (<code>&lt;&quot;...&quot;&quot;&gt;</code>).</li>
<li><strong>Example:</strong> <code>&quot;Hello, World!&quot;</code>, <code>&quot;&quot;A quote is a &quot; character.&quot;&quot;</code>, <code>&lt;&quot;Alice said, &quot;Boo!&quot;&quot;&gt;</code></li>
</ul>
<p><strong>Interpolated Text Element</strong></p>
<ul>
<li><strong>Specifier:</strong> <code>'</code> (Apostrophe)</li>
<li><strong>Description:</strong> Similar to a string, but embedded elements are evaluated and their values are interpolated into the final text.</li>
<li><strong>Example:</strong> <code>'The value is &lt;#42#&gt;'</code> renders as <code>&quot;The value is 42&quot;</code>.</li>
</ul>
<p><strong>Character Element</strong></p>
<ul>
<li><strong>Specifier:</strong> <code>\</code> (Backslash)</li>
<li><strong>Description:</strong> Represents a single character, specified by its Unicode codepoint in decimal, hex (<code>$</code>), or binary (<code>%</code>), or by a predefined keyword (e.g., <code>tab</code>, <code>lf</code>, <code>gt</code>).</li>
<li><strong>Example:</strong> <code>\65</code>, <code>\$41</code>, <code>\gt</code> (all represent 'A')</li>
</ul>
<p><strong>Integer Element</strong></p>
<ul>
<li><strong>Specifier:</strong> <code>#</code> (Number Sign)</li>
<li><strong>Description:</strong> A 32-bit signed integer. Can be written in decimal, hex (<code>$</code>), or binary (<code>%</code>). The specifier is optional if the syntax is unambiguous (implicit syntax).</li>
<li><strong>Example:</strong> <code>42</code>, <code>#$2A</code>, <code>#%00101010</code></li>
</ul>
<p><strong>Long Element</strong></p>
<ul>
<li><strong>Specifier:</strong> <code>&amp;</code> (Ampersand)</li>
<li><strong>Description:</strong> A 64-bit signed integer. Can be written in decimal, hex (<code>$</code>), or binary (<code>%</code>).</li>
<li><strong>Example:</strong> <code>&amp;5000000000</code>, <code>&amp;$12A05F200</code>, <code>&amp;%1001010100000010111110010000000000</code></li>
</ul>
<p><strong>Double Element</strong></p>
<ul>
<li><strong>Specifier:</strong> <code>^</code> (Caret)</li>
<li><strong>Description:</strong> A 64-bit floating-point number.</li>
<li><strong>Example:</strong> <code>^3.14159</code></li>
</ul>
<p><strong>Decimal Element</strong></p>
<ul>
<li><strong>Specifier:</strong> <code>*</code> (Asterisk)</li>
<li><strong>Description:</strong> A 128-bit high-precision decimal value.</li>
<li><strong>Example:</strong> <code>*123.45</code></li>
</ul>
<p><strong>Boolean Element</strong></p>
<ul>
<li><strong>Specifier:</strong> <code>~</code> (Tilde)</li>
<li><strong>Description:</strong> Represents a <code>true</code> or <code>false</code> value.</li>
<li><strong>Example:</strong> <code>~true</code>, <code>~false</code></li>
</ul>
<p><strong>Date/Time Element</strong></p>
<ul>
<li><strong>Specifier:</strong> <code>@</code> (At Sign)</li>
<li><strong>Description:</strong> Represents a date and time value in ISO 8601 format.</li>
<li><strong>Example:</strong> <code>@2025-07-23T10:00:00@</code></li>
</ul>
<p><strong>Null Element</strong></p>
<ul>
<li><strong>Specifier:</strong> <code>?</code> (Question Mark)</li>
<li><strong>Description:</strong> Represents a null value.</li>
<li><strong>Example:</strong> <code>?</code>, <code>&lt;??&gt;</code></li>
</ul>
<section id="hexadecimal-and-binary-formatting"><h4 id="hexadecimal-and-binary-formatting">Hexadecimal and Binary Formatting</h4>
<p>Integer and Long elements support alternative numeric representations for improved readability in specific contexts:</p>
<p><strong>Hexadecimal Format</strong></p>
<ul>
<li><strong>Syntax:</strong> <code>#$</code> prefix followed by hexadecimal digits (e.g., <code>#$2A</code>, <code>&amp;$12A05F200</code>)</li>
<li><strong>Use Cases:</strong> Memory addresses, color values, bitmasks, low-level programming</li>
<li><strong>Parsing:</strong> Case-insensitive (<code>#$2A</code> equals <code>#$2a</code>)</li>
<li><strong>Attributes:</strong> Use <code>[XferNumericFormat(XferNumericFormat.Hexadecimal, MinDigits = 4)]</code> for zero-padding</li>
</ul>
<p><strong>Binary Format</strong></p>
<ul>
<li><strong>Syntax:</strong> <code>#%</code> prefix followed by binary digits (e.g., <code>#%101010</code>, <code>&amp;%1001010100000010111110010000000000</code>)</li>
<li><strong>Use Cases:</strong> Bit manipulation, flags, educational purposes, embedded systems</li>
<li><strong>Attributes:</strong> Use <code>[XferNumericFormat(XferNumericFormat.Binary, MinBits = 8)]</code> for zero-padding</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-xfer">{
    // Decimal 42 in different formats
    decimal 42
    hex #$2A
    binary #%101010
    padded_hex #$002A    // MinDigits = 4
    padded_binary #%00101010  // MinBits = 8
}
</code></pre>
<p><strong>Safety Note:</strong> Hex and binary formatting are only supported for integer types (<code>int</code>, <code>long</code>). Decimal and double types preserve fractional precision and do not support these formats.</p>
<section id="structural-types"><h4 id="structural-types">Structural Types</h4>
<p><strong>Object Element</strong></p>
<ul>
<li><strong>Specifiers:</strong> <code>{</code> and <code>}</code> (Curly Brackets)</li>
<li><strong>Description:</strong> A collection of key/value pairs. Keys are typically implicit keywords, and values can be any XferLang element.</li>
<li><strong>Example:</strong> <code>{ name &quot;Alice&quot; age 30 }</code></li>
</ul>
<p><strong>Array Element</strong></p>
<ul>
<li><strong>Specifiers:</strong> <code>[</code> and <code>]</code> (Square Brackets)</li>
<li><strong>Description:</strong> A collection of elements of the <strong>same type</strong>.</li>
<li><strong>Example:</strong> <code>[ 1 2 3 ]</code>, <code>[ &quot;a&quot; &quot;b&quot; &quot;c&quot; ]</code></li>
</ul>
<p><strong>Tuple Element</strong></p>
<ul>
<li><strong>Specifiers:</strong> <code>(</code> and <code>)</code> (Parentheses)</li>
<li><strong>Description:</strong> A collection of elements of <strong>any type</strong>, similar to a JSON array.</li>
<li><strong>Example:</strong> <code>( &quot;Alice&quot; 30 ~true )</code></li>
</ul>
<p><strong>Keyword Element and Key/Value Pairs</strong></p>
<ul>
<li><strong>Description:</strong> A keyword is the key in a key/value pair. If it contains only letters, numbers, and underscores, it can be written implicitly. Otherwise, it must be enclosed in colons (<code>:</code>).</li>
<li><strong>Example:</strong> <code>name &quot;Paul&quot;</code>, <code>:first name: &quot;Alice&quot;</code></li>
</ul>
<section id="common-document-patterns"><h4 id="common-document-patterns">Common Document Patterns</h4>
<p><strong>Configuration Documents</strong>
Most configuration files use Object as the root collection:</p>
<pre><code class="language-xfer">{
    database {
        host &quot;localhost&quot;
        port 5432
        ssl ~true
    }
    logging {
        level &quot;info&quot;
        destinations [ &quot;console&quot; &quot;file&quot; ]
    }
}
</code></pre>
<p><strong>Data Collections</strong>
For homogeneous data, use Array as the root:</p>
<pre><code class="language-xfer">[
    { name &quot;Alice&quot; age 30 }
    { name &quot;Bob&quot; age 25 }
    { name &quot;Charlie&quot; age 35 }
]
</code></pre>
<p><strong>Mixed Content Documents</strong>
For documents with heterogeneous top-level content, use Tuple:</p>
<pre><code class="language-xfer">(
    &quot;Document Title&quot;
    @2023-12-25T10:00:00@
    {
        metadata { version &quot;1.0&quot; author &quot;John Doe&quot; }
        content {
            sections [ &quot;intro&quot; &quot;body&quot; &quot;conclusion&quot; ]
            wordCount 1500
        }
    }
)
</code></pre>
<section id="special-purpose-types"><h4 id="special-purpose-types">Special-Purpose Types</h4>
<p><strong>Metadata Element</strong></p>
<ul>
<li><strong>Specifiers:</strong> <code>!</code> (Exclamation Mark)</li>
<li><strong>Description:</strong> A special object that can only appear at the start of a document. It contains metadata about the document, such as the <code>document</code> version.</li>
<li><strong>Example:</strong> <code>&lt;! document {version &quot;1.0&quot;} description &quot;Sample document&quot; !&gt;</code></li>
</ul>
<p><strong>Comment Element</strong></p>
<ul>
<li><strong>Specifier:</strong> <code>/</code> (Slash)</li>
<li><strong>Description:</strong> A comment that is ignored by the parser. It always requires explicit syntax.</li>
<li><strong>Example:</strong> <code>&lt;/ This is a comment. /&gt;</code>, <code>&lt;// Nested &lt;/comment/&gt; //&gt;</code></li>
</ul>
<p><strong>Dynamic Element</strong></p>
<ul>
<li><strong>Specifier:</strong> <code>|</code> (Pipe)</li>
<li><strong>Description:</strong> Represents a value to be substituted at runtime, by default from an environment variable. You can override the default dynamic value resolution by subclassing <code>DefaultDynamicSourceResolver</code> or by implementing the <code>IDynamicSourceResolver</code> interface. This allows you to provide custom logic for resolving dynamic values in your XferLang documents.</li>
<li><strong>Example:</strong> <code>'Hello, &lt;|USERNAME|&gt;!'</code></li>
</ul>
<section id="document-validation-and-common-mistakes"><h3 id="document-validation-and-common-mistakes">Document Validation and Common Mistakes</h3>
<p><strong>Root Collection Requirement</strong>
Every XferLang document must have exactly one root collection element after any metadata. This is a fundamental requirement for proper parsing:</p>
<pre><code class="language-xfer">// ❌ Invalid - No root collection
&quot;Hello, World!&quot;
42

// ❌ Invalid - Multiple top-level elements
{ config &quot;value&quot; }
[ 1 2 3 ]

// ✅ Valid - Single root object
{
    message &quot;Hello, World!&quot;
    count 42
}

// ✅ Valid - Single root array
[ &quot;Hello, World!&quot; 42 ]

// ✅ Valid - Single root tuple
( &quot;Hello, World!&quot; 42 { config &quot;value&quot; } )
</code></pre>
<p><strong>With Metadata</strong>
When using metadata, it must come first, followed by exactly one root collection:</p>
<pre><code class="language-xfer">// ✅ Valid - Metadata followed by root object
&lt;! document { version &quot;1.0&quot; } !&gt;
{
    data &quot;example&quot;
}

// ❌ Invalid - Missing root collection after metadata
&lt;! document { version &quot;1.0&quot; } !&gt;
&quot;standalone string&quot;
</code></pre>
<section id="the-net-xferlang-library"><h2 id="the.net-xferlang-library">The <code>.NET XferLang Library</code></h2>
<p>The primary implementation of XferLang is the <code>ParksComputing.Xfer.Lang</code> library for .NET. It provides a comprehensive object model, a robust parser, and a powerful serialization/deserialization utility class, <code>XferConvert</code>.</p>
<section id="basic-serialization-andamp-deserialization"><h3 id="basic-serialization-deserialization">Basic Serialization &amp; Deserialization</h3>
<p>The <code>XferConvert</code> class provides a simple, static interface for converting between .NET objects and XferLang strings. The library automatically ensures that serialized objects are wrapped in a proper root collection element.</p>
<pre><code class="language-csharp">public class MyData {
    public string Name { get; set; }
    public int Value { get; set; }
}

var data = new MyData { Name = &quot;Example&quot;, Value = 123 };

// Serialize to an Xfer string (automatically creates root object)
string xfer = XferConvert.Serialize(data, Formatting.Indented);

// {
//     Name &quot;Example&quot;
//     Value 123
// }

// Deserialize back to an object
var deserializedData = XferConvert.Deserialize&lt;MyData&gt;(xfer);
</code></pre>
<section id="advanced-usage-with-xferserializersettings"><h3 id="advanced-usage-with-xferserializersettings">Advanced Usage with <code>XferSerializerSettings</code></h3>
<p>For more control, you can pass an instance of <code>XferSerializerSettings</code> to the <code>Serialize</code> and <code>Deserialize</code> methods.</p>
<section id="null-value-handling"><h4 id="null-value-handling">Null Value Handling</h4>
<p>By default, properties with <code>null</code> values are included. You can set <code>NullValueHandling</code> to <code>Ignore</code> to omit them.</p>
<pre><code class="language-csharp">var settings = new XferSerializerSettings {
    NullValueHandling = NullValueHandling.Ignore
};
</code></pre>
<section id="customizing-property-names-with-icontractresolver"><h4 id="customizing-property-names-with-icontractresolver">Customizing Property Names with <code>IContractResolver</code></h4>
<p>You can change how property names are serialized by creating a custom contract resolver. For example, to make all property names lowercase:</p>
<pre><code class="language-csharp">public class LowerCaseContractResolver : DefaultContractResolver {
    public override string ResolvePropertyName(string propertyName) {
        return propertyName.ToLower();
    }
}

var settings = new XferSerializerSettings {
    ContractResolver = new LowerCaseContractResolver()
};
</code></pre>
<section id="custom-type-converters-with-ixferconverter"><h4 id="custom-type-converters-with-ixferconverter">Custom Type Converters with <code>IXferConverter</code></h4>
<p>For complete control over how a specific type is handled, you can create a custom converter. This is useful for types that don't map well to standard object serialization or for creating a more compact representation.</p>
<p><strong>Example: A custom converter for a <code>Person</code> class</strong></p>
<pre><code class="language-csharp">// The class to convert
public class Person {
    public string Name { get; set; }
    public int Age { get; set; }
}

// The custom converter
public class PersonConverter : XferConverter&lt;Person&gt; {
    // Convert a Person object to a compact string element
    public override Element WriteXfer(Person value, XferSerializerSettings settings) {
        return new StringElement($&quot;{value.Name},{value.Age}&quot;);
    }

    // Convert a string element back to a Person object
    public override Person ReadXfer(Element element, XferSerializerSettings settings) {
        if (element is StringElement stringElement) {
            var parts = stringElement.Value.Split(',');
            if (parts.Length == 2 &amp;&amp; int.TryParse(parts[1], out int age)) {
                return new Person { Name = parts[0], Age = age };
            }
        }
        throw new InvalidOperationException(&quot;Cannot convert element to Person.&quot;);
    }
}

// How to use it
var settings = new XferSerializerSettings();
settings.Converters.Add(new PersonConverter());

var person = new Person { Name = &quot;John Doe&quot;, Age = 42 };
string xfer = XferConvert.Serialize(person, settings); // Result: &quot;John Doe,42&quot;
</code></pre>
<section id="numeric-formatting-with-attributes"><h4 id="numeric-formatting-with-attributes">Numeric Formatting with Attributes</h4>
<p>The library supports custom numeric formatting for integer and long properties using the <code>XferNumericFormatAttribute</code>. This allows you to control how numeric values are serialized in hexadecimal or binary formats.</p>
<p><strong>Available Formats:</strong></p>
<ul>
<li><code>XferNumericFormat.Decimal</code> - Standard decimal representation (default)</li>
<li><code>XferNumericFormat.Hexadecimal</code> - Hexadecimal with <code>#$</code> prefix</li>
<li><code>XferNumericFormat.Binary</code> - Binary with <code>#%</code> prefix</li>
</ul>
<p><strong>Padding Options:</strong></p>
<ul>
<li><code>MinDigits</code> - For hexadecimal, pads with leading zeros to minimum digit count</li>
<li><code>MinBits</code> - For binary, pads with leading zeros to minimum bit count</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-csharp">public class ConfigurationData {
    [XferNumericFormat(XferNumericFormat.Decimal)]
    public int Port { get; set; } = 8080;

    [XferNumericFormat(XferNumericFormat.Hexadecimal)]
    public int ColorValue { get; set; } = 0xFF5733;

    [XferNumericFormat(XferNumericFormat.Binary, MinBits = 8)]
    public int Flags { get; set; } = 42;

    [XferNumericFormat(XferNumericFormat.Hexadecimal, MinDigits = 8)]
    public long MemoryAddress { get; set; } = 0x7FF6C2E40000;
}

var config = new ConfigurationData();
string xfer = XferConvert.Serialize(config);
// Result: {Port 8080 ColorValue #$FF5733 Flags #%00101010 MemoryAddress &amp;$7FF6C2E40000}
</code></pre>
<p><strong>Safety Notes:</strong></p>
<ul>
<li>Numeric formatting attributes are only applied to <code>int</code> and <code>long</code> properties</li>
<li><code>decimal</code> and <code>double</code> types ignore formatting attributes to preserve fractional precision</li>
<li>Custom formatting respects the configured <code>ElementStylePreference</code> for syntax style</li>
</ul>
<section id="processing-instructions-andamp-dynamic-content"><h2 id="processing-instructions-dynamic-content">Processing Instructions &amp; Dynamic Content</h2>
<p>XferLang supports Processing Instructions (PIs) that provide metadata and configuration for documents. PIs are special elements that control parsing behavior, define document metadata, and enable powerful dynamic content features. The PI system is fully extensible, allowing you to create custom instructions for specialized use cases.</p>
<section id="built-in-processing-instructions"><h3 id="built-in-processing-instructions">Built-in Processing Instructions</h3>
<p>XferLang includes several built-in PIs that address common document needs:</p>
<section id="document-metadata-pi"><h4 id="document-metadata-pi">Document Metadata PI</h4>
<p>The <code>document</code> PI stores metadata about the XferLang document itself and must appear first if present:</p>
<pre><code class="language-xfer">&lt;! document {
    version &quot;1.0&quot;
    author &quot;John Doe&quot;
    created @2023-12-01T10:30:00@
    description &quot;Sample configuration file&quot;
} !&gt;
{
    // Document content follows...
}
</code></pre>
<p><strong>Key features:</strong></p>
<ul>
<li>Must be the first non-comment element if present</li>
<li>Provides version tracking and document attribution</li>
<li>Supports any metadata fields as key-value pairs</li>
<li>Accessible programmatically through <code>XferDocument.ProcessingInstructions</code></li>
</ul>
<section id="dynamicsource-pi"><h4 id="dynamicsource-pi">DynamicSource PI</h4>
<p>The <code>dynamicSource</code> PI configures how dynamic elements <code>&lt;|key|&gt;</code> are resolved, providing flexible runtime value substitution:</p>
<pre><code class="language-xfer">&lt;! dynamicSource {
    greeting const &quot;Welcome to our application&quot;
    username env &quot;USERNAME&quot;
    config file &quot;app.config&quot;
    secret vault &quot;api-key&quot;
} !&gt;
{
    message '&lt;|greeting|&gt;'
    user '&lt;|username|&gt;'
    settings '&lt;|config|&gt;'
    apiKey '&lt;|secret|&gt;'
}
</code></pre>
<section id="chardef-pi"><h4 id="chardef-pi">CharDef PI</h4>
<p>The <code>chardef</code> PI allows you to define custom character aliases for use in character elements:</p>
<pre><code class="language-xfer">&lt;! chardef {
    bullet \$2022
    arrow \$2192
    check \$2713
} !&gt;
{
    symbols [ \bullet \arrow \check ]
}
</code></pre>
<section id="id-pi"><h4 id="id-pi">ID PI</h4>
<p>The <code>id</code> PI assigns identifiers to elements for referencing and linking:</p>
<pre><code class="language-xfer">{
    &lt;! id &quot;user-config&quot; !&gt;
    section {
        name &quot;User Settings&quot;
        enabled ~true
    }
}
</code></pre>
<section id="dynamic-elements-andamp-source-resolution"><h3 id="dynamic-elements-source-resolution">Dynamic Elements &amp; Source Resolution</h3>
<p>Dynamic elements provide runtime value substitution with an extensible source system.</p>
<section id="built-in-source-types"><h4 id="built-in-source-types">Built-in Source Types</h4>
<p>XferLang includes three built-in source handlers:</p>
<p><strong>Constant Sources (<code>const</code>)</strong></p>
<ul>
<li>Returns the configured value as a literal constant</li>
<li>Useful for templating and configuration management</li>
<li>Example: <code>greeting const &quot;Hello, World!&quot;</code></li>
</ul>
<p><strong>Environment Variables (<code>env</code>)</strong></p>
<ul>
<li>Reads from system environment variables</li>
<li>Supports fallback values and variable name mapping</li>
<li>Example: <code>username env &quot;USER&quot;</code> (reads from $USER environment variable)</li>
</ul>
<p><strong>File Sources (<code>file</code>)</strong></p>
<ul>
<li>Reads content from files at parse time</li>
<li>Supports relative and absolute paths</li>
<li>Example: <code>config file &quot;settings.json&quot;</code></li>
</ul>
<section id="custom-source-handler-registration"><h4 id="custom-source-handler-registration">Custom Source Handler Registration</h4>
<p>Extend the system with custom source types for databases, web services, or other data sources:</p>
<pre><code class="language-csharp">// Register a custom 'vault' source handler
DynamicSourceHandlerRegistry.RegisterHandler(&quot;vault&quot;, (sourceValue, fallbackKey) =&gt; {
    var key = sourceValue ?? fallbackKey;
    return await SecretVaultClient.GetSecretAsync(key);
});

// Register a database source handler
DynamicSourceHandlerRegistry.RegisterHandler(&quot;db&quot;, (sourceValue, fallbackKey) =&gt; {
    var query = sourceValue ?? $&quot;SELECT value FROM config WHERE key = '{fallbackKey}'&quot;;
    return DatabaseService.ExecuteScalar(query);
});
</code></pre>
<p><strong>Resolution Priority:</strong></p>
<ol>
<li>Configured source type in <code>dynamicSource</code> PI</li>
<li>Fallback to environment variables</li>
<li>Return empty string if not found</li>
</ol>
<section id="extending-processing-instructions"><h3 id="extending-processing-instructions">Extending Processing Instructions</h3>
<p>The PI system is designed for extensibility, allowing you to create custom instructions for specialized parsing and document processing needs.</p>
<section id="creating-custom-pis"><h4 id="creating-custom-pis">Creating Custom PIs</h4>
<p>To create a custom PI, inherit from <code>ProcessingInstruction</code> and implement the required behavior:</p>
<pre><code class="language-csharp">public class ValidationProcessingInstruction : ProcessingInstruction {
    public const string Keyword = &quot;validation&quot;;

    public ValidationProcessingInstruction(ObjectElement rules) : base(rules, Keyword) { }

    public override void ProcessingInstructionHandler() {
        if (Value is not ObjectElement obj) {
            throw new InvalidOperationException($&quot;{Keyword} PI expects an object element&quot;);
        }

        // Process validation rules and store globally
        foreach (var kv in obj.Dictionary) {
            var fieldName = kv.Value.Key;
            var rules = kv.Value.Value;
            ValidationRegistry.RegisterRules(fieldName, rules);
        }
    }

    public override void ElementHandler(Element element) {
        // Apply validation rules to specific elements
        ValidationRegistry.ValidateElement(element);
    }
}
</code></pre>
<section id="pi-registration-andamp-lifecycle"><h4 id="pi-registration-lifecycle">PI Registration &amp; Lifecycle</h4>
<p>Register custom PIs with the parser during initialization:</p>
<pre><code class="language-csharp">// Register the custom PI processor
Parser.RegisterPIProcessor(ValidationProcessingInstruction.Keyword,
    (kvp, parser) =&gt; new ValidationProcessingInstruction((ObjectElement)kvp.Value));

// Example usage in XferLang document
var xferContent = @&quot;
&lt;! validation {
    userEmail regex &quot;&quot;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$&quot;&quot;
    userAge range { min 0 max 120 }
} !&gt;
{
    userEmail &quot;&quot;user@example.com&quot;&quot;
    userAge 25
}&quot;;
</code></pre>
<p><strong>PI Lifecycle:</strong></p>
<ol>
<li><strong>Discovery</strong>: PIs are identified during metadata parsing</li>
<li><strong>Creation</strong>: Registered processors create PI instances</li>
<li><strong>Processing</strong>: <code>ProcessingInstructionHandler()</code> is called for document-level setup</li>
<li><strong>Element Processing</strong>: <code>ElementHandler()</code> is called for each relevant element</li>
<li><strong>Cleanup</strong>: PIs can register cleanup logic if needed</li>
</ol>
<p><strong>Advanced Features:</strong></p>
<ul>
<li><strong>Scoped PIs</strong>: Apply to specific document sections</li>
<li><strong>Cascading PIs</strong>: Inherit behavior from parent elements</li>
<li><strong>Conditional PIs</strong>: Activate based on document content or external conditions</li>
<li><strong>Multi-phase PIs</strong>: Process elements in multiple passes</li>
</ul>
<p>This extensible PI system makes XferLang highly adaptable for domain-specific needs, from configuration management to data validation and transformation pipelines.</p>
<section id="project-status-andamp-roadmap"><h2 id="project-status-roadmap">Project Status &amp; Roadmap</h2>
<p>The .NET implementation of XferLang is becoming more robust, with a focus on professional-grade features like custom converters and contract resolvers. However, the project as a whole is still experimental.</p>
<p>The future roadmap includes:</p>
<ul>
<li>Completing the .NET implementation to achieve a production-quality 1.0 release</li>
<li>Reimplementing the core library in Rust</li>
<li>Exposing a C ABI from the Rust implementation</li>
<li>Creating language wrappers (e.g., for C#, Python, JavaScript) that communicate with the C ABI</li>
</ul>
<p>The goal of moving to a Rust core is to provide a single, high-performance, and memory-safe core for all future XferLang implementations. I'm looking for contributors and collaborators to get that work started.</p>
<section id="contributing"><h2 id="contributing">Contributing</h2>
<p>This is an open-source project, and contributions are always welcome! If you are interested in helping, please feel free to open an issue or a pull request on GitHub. You can also reach out to me directly via email at <a href="mailto:paul@parkscomputing.com">paul@parkscomputing.com</a>.</p>
<section id="grammar"><h2 id="grammar">Grammar</h2>
<p>The formal Backus–Naur form (BNF) grammar for XferLang can be found in the repository: <a href="https://github.com/paulmooreparks/Xfer/blob/master/xfer.bnf">xfer.bnf</a>.</p>
</section>

        <footer>
            <p>Documentation generated on 2025-08-03 21:14:27 UTC</p>
        </footer>
    </main>
    <script>hljs.highlightAll();</script>
</body>
</html>
