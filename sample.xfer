</ This is a sample Xfer document. It demonstrates the basic syntax and features of the Xfer language. />

<// Elements are formed by enclosing them in angle brackets with another inner marker to designate
the meaning of the element. For example the character pairs </ and /> are used to enclose comments. 
When, as is the case here, the marker is repeated, it is so that the element can contain an embedded 
element of the same type. In this case, the outer comment contains an embedded comment, so the marker 
character, '/', is repeated as many times as necessary to allow embedded elements to be properly 
distinguished. //>

</ The following element is a metadata element. It consists of key/value pairs, some of which have 
reserved keywords (version, message_id, and ttl). If a metadata element is provided, it must be 
the first non-comment element in an Xfer document. />

<! version <"0.2.1"> message_id <`<|COMPUTERNAME|>`> !>

<{name<"Alice">age#30 isMember~true scores<[*85 *90 *78.5 ]>profile<{email<"alice@example.com">joinedDate@2023-05-05T20:00:00 }>}>
</ The outermost element of an Xfer document is an implicit property-bag element. It may contain 
elements of any type. />

</ A string element is a sequence of characters which are rendered literally, as they appear. />
<"Hello, Xfer!">

</ An evaluated element evaluates its embedded elements. The following will render as I ❤ Xfer. />
<` I <\$2764\><\$fe0e\> Xfer `>

</ An example of embedding a string element and a comment inside an Xfer string. />
<""
<"Xfer"> is an Xfer string element </and this is an Xfer comment/>.
"">

</// A comment with <// a comment </ inside another comment /> //>. ///>

<"A string may contain character elements<\$20\>inside of it, which will not be parsed.">
<`When character elements are inside an evaluated<\$20\>element, they are parsed`>
<``An eval element may contain <`another eval`> if its markers are repeated``>
<`Other elements like strings (<"Hello, World!">), numbers (<#123#>, <&456&>), and dates (<@1976-04-07@>) may also be embedded in eval elements, and their evaluated results will become part of the rendered value.`>

{
    string "value"  </ String marker is " />
    character \65  </ Character marker is \ />
    boolean ~true  </ Boolean marker is ~ />
    integer #42  </ Integer marker is # />
    long &5000000000  </ Long marker is & />
    hexLongInteger &$BAADF00D  </ Hex numeric values are preceded by $ />
    binaryInteger #%10101010  </ Binary numeric values are preceded by % />
    double ^3.1415926535  </ Double marker is ^ />
    decimal *123.45  </ Decimal marker is * />
    date @2019-01-01  </ Date marker is @ />
    placeholder `<|USERPROFILE|>`  </ Placeholder marker is | />
    evalString <`Inner elements <"are evaluated"> <#1#> at a time and<\$20\>rendered<\$20\><``as<\$20\>is``>.`>  </ Evaluated element marker is ` />
    array [
        #1 
        #2 
        #3
    ] 
    </ Array markers are [ ] />

    object { 
        key "value"
        boolean ~false
    } </ Object markers are { } />
     
    </ A property-bag element may hold any number of elements of any type. />
    propertyBag (
        "value"
        #123
        ~true
        @2019-02-02
    ) </ Property bag markers are ( ) />
    
}>

</ We are able to round-trip the minified output of the parser. />
<{string<"value">character\65 boolean~true integer#42 long&5000000000 hexLongInteger&3131961357 binaryInteger#170 double^3.1415926535 decimal*123.45 date@2019-01-01T08:00:00 placeholder<`C:\Users\paul`>evalString<`Inner elements are evaluated 1 at a time and rendered as is.`>array<[#1 #2 #3 ]>object<{key<"value">boolean~false }>propertyBag<(<"value">#123 ~true @2019-02-02T08:00:00 )>}>

<(
    </ Most elements may pull their values from a placeholder. />
    numProcs #<|NUMBER_OF_PROCESSORS|>

    </ A key-value pair element may have a key/value pair as a value. />
    keyValuePair key "value"

    `What if an eval element contains a comment?</ The comment is removed./>`
)>

<"
/* Now it's possible to embed code with less worry */
namespace HelloWorldApp;

class Program {
    static void Main(string[] args) {
        Console.WriteLine("Hello, Xfer!");
    }
}
">

{
    name "Alice"
    age #30
    isMember ~true
    scores [ *85 *90 *78.5 ]
    profile {
        email "alice@example.com"
        joinedDate @2023-05-05T12:00:00
    }
    settings {
        theme "dark"
        notifications { 
            email ~true
            sms ~false
        }
        preferences [
            {
                key "timezone"
                value "UTC+0"
            }
            {
                key "language"
                value "en"
            }
        ]
    }
    items [
        {
            id #1
            name "Item 1"
            price *19.99
        }
        {
            id #2
            name "Item 2"
            price *5.49
        }
        {
            id #3
            name "Item 3"
            price *10.0
        }
    ]
    tags [ "tag1" "tag2" "tag3" ]
    metadata{
        created @2024-11-10T08:00:00
        modified @2024-11-11T12:30:00
    }
}

</ I parked this comment here so that I could remember how to replace the parse parameter for testing. />
</ parse ..\..\..\..\sample.xfer />

